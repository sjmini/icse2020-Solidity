// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 2.4.0,
// (C) 2004-2014 Robert Grimm,
// on Friday, January 3, 2020 at 2:09:57 AM.
// Edit at your own risk.
// ===========================================================================

package kr.ac.kaist.saf.parser;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import java.util.HashMap;
import kr.ac.kaist.saf.errors.ExcLog;
import kr.ac.kaist.saf.errors.error.*;
import kr.ac.kaist.saf.nodes.ast.*;
import kr.ac.kaist.saf.util.*;
import xtc.util.Action;
import java.io.*;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.file.Files;
import java.util.Collections;
import java.util.ArrayList;
import java.util.List;
import scala.collection.JavaConversions;
import scala.Option;
import scala.Some;
import scala.Tuple2;
import scala.Tuple3;

/**
 * Packrat parser for grammar <code>kr.ac.kaist.saf.parser.SOL</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 2.4.0, (C) 2004-2014 Robert Grimm.
 */
public final class SOL extends ParserBase {

  /** The SOLIDITY_RESERVED set. */
  public static final Set<String> SOLIDITY_RESERVED = new HashSet<String>();

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result f$$Shared1;
    Result f$$Shared2;
    Result f$$Shared40;
    Result f$$Shared40$$Star1;
    Result f$$Shared39;
    Result f$$Shared4;
    Result f$$Shared25;
    Result f$$Shared6;
    Result f$$Shared6$$Star1;
    Result f$$Shared36;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result f$$Shared8;
    Result f$$Shared28;
    Result f$$Shared9;
    Result f$$Shared10;
    Result f$$Shared11;
    Result f$$Shared11$$Star1;
    Result f$$Shared34;
    Result f$$Shared34$$Star1;
    Result f$$Shared30;
    Result f$$Shared12;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fStatement;
    Result fSimpleStatement;
    Result fInitBody;
    Result fExpressionStatement;
    Result fInlineAssemblyBlock;
    Result fAssemblyItem;
    Result fAssemblyItem$$Star1;
    Result fAssemblyExpression;
    Result fFunctionalAssemblyExpression;
    Result fExpression;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result fLeftHandSide;
    Result fCallExpression;
    Result fCallExpression$$Star1;
    Result fMemberExpression;
    Result fMemberExpression$$Star1;
    Result fNumberLiteral;
    Result fHexLiteral;
    Result fHexLiteral$$Plus1;
    Result fHexLiteral$$Plus2;
    Result fTypeName;
  }

  /** Chunk 5 of memoized results. */
  static final class Chunk5 {
    Result fTypeName$$Star1;
    Result fUserDefinedTypeName;
    Result fUserDefinedTypeName$$Star1;
    Result fOptIdList;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class SOLColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
    Chunk5 chunk5;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public SOL(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public SOL(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new SOLColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.saf.parser.SOL.File.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pSOL$File(final int yyStart) throws IOException {
    Result              yyResult;
    int                 yyOption1;
    List<SourceElement> yyOpValue1;
    SourceUnit          yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = p$$Shared40(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        List<SourceElement> v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for a2.
        List<SourceElement> a2 = yyOpValue1;

        yyResult = p$$Shared2(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          Span span = createSpan(yyStart,yyCount);
          ASTNodeInfo info = NodeUtil.makeASTNodeInfo(span);
          scala.collection.immutable.List<SourceElement> ses;
          if (a2 == null) ses = nilSes;
          else ses = toList(a2);
          HashMap<String, Span> map = new HashMap<String, Span>();
          yyValue = new SourceUnit(info, ses);

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared1.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.initParser and Declaration.initParser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared1(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared1) 
      yyColumn.chunk1.f$$Shared1 = p$$Shared1$1(yyStart);
    return yyColumn.chunk1.f$$Shared1;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared1. */
  private Result p$$Shared1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      initParser();

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared2.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.closeParser and Declaration.closeParser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared2(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared2) 
      yyColumn.chunk1.f$$Shared2 = p$$Shared2$1(yyStart);
    return yyColumn.chunk1.f$$Shared2;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared2. */
  private Result p$$Shared2$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pEndOfFile(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        writer.close();
        fw.close();

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared40.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.SourceElements and Declaration.SourceElements.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared40(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared40) 
      yyColumn.chunk1.f$$Shared40 = p$$Shared40$1(yyStart);
    return yyColumn.chunk1.f$$Shared40;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared40. */
  private Result p$$Shared40$1(final int yyStart) throws IOException {
    Result              yyResult;
    List<SourceElement> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared39(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SourceElement a1 = yyResult.semanticValue();

      yyResult = p$$Shared40$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<SourceElement> a2s = yyResult.semanticValue();

        yyValue = cons(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared40$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared40$$Star1(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared40$$Star1) 
      yyColumn.chunk1.f$$Shared40$$Star1 = p$$Shared40$$Star1$1(yyStart);
    return yyColumn.chunk1.f$$Shared40$$Star1;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared40$$Star1. */
  private Result p$$Shared40$$Star1$1(final int yyStart) throws IOException {
    Result              yyResult;
    Pair<SourceElement> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = p$$Shared39(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        SourceElement v$el$1 = yyResult.semanticValue();

        yyResult = p$$Shared40$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<SourceElement> v$2 = yyResult.semanticValue();

          yyValue = new Pair<SourceElement>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared39.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.SourceElement and Declaration.SourceElement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared39(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared39) 
      yyColumn.chunk1.f$$Shared39 = p$$Shared39$1(yyStart);
    return yyColumn.chunk1.f$$Shared39;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared39. */
  private Result p$$Shared39$1(final int yyStart) throws IOException {
    Result        yyResult;
    SourceElement yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared3(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = p$$Shared16(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = p$$Shared38(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared3.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.PragmaDirective 
   * and Declaration.PragmaDirective.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared3(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyRepetition1;
    boolean         yyRepeated1;
    PragmaDirective yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ppragma(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared31(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            yyRepeated1   = false;
            while (true) {

              yyResult = pPragmaVersionChar(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                continue;
              }
              break;
            }

            if (yyRepeated1) {

              yyResult = pw(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = psemicolon(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                  yyValue = new PragmaDirective(info, a1);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared16.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.ImportDirective 
   * and Declaration.ImportDirective.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared16(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyRepetition1;
    Pair<Alias>     yyRepValue1;
    int             yyOption1;
    Id              yyOpValue1;
    ImportDirective yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pimport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pStringLiteral(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          StringLiteral a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyResult = pas(yyResult.index);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {

                yyResult = p$$Shared31(yyResult.index);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  Id v$el$1 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$1;
                }
              }
            }
          }
          { // Start scope for a2.
            Id a2 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = psemicolon(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                Id id = new Id(info, a1.str());
                Option<Id> alias;
                if (a2 == null) alias = Option.<Id>apply(null);
                else alias = Some.<Id>apply(a2);
                yyValue = new Import(info, new Alias(info, id, alias));

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a2.
        }

        // Nested alternative 2.

        yyResult = pstar(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyResult = pas(yyResult.index);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {

                yyResult = p$$Shared31(yyResult.index);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  Id v$el$2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$2;
                }
              }
            }
          }
          { // Start scope for a1.
            Id a1 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pfrom(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pStringLiteral(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    StringLiteral a2 = yyResult.semanticValue();

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = psemicolon(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                        Option<Id> alias;
                        if (a1 == null) alias = Option.<Id>apply(null);
                        else alias = Some.<Id>apply(a1);
                        Id module = new Id(info, a2.str());
                        yyValue = new ImportAll(info, alias, module.name());

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }
              }
            }
          } // End scope for a1.
        }

        // Nested alternative 3.

        yyResult = p$$Shared4(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Alias a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pfrom(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pStringLiteral(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  StringLiteral a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = psemicolon(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                      Id module = new Id(info, a2.str());
                      yyValue = new ImportFrom(info, toList(list(a1)), module.name());

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }

        // Nested alternative 4.

        yyResult = popencurly(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared4(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Alias a1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError, yyRepetition1);
                if (yyResult.hasValue()) {

                  yyResult = pcomma(yyResult.index);
                  yyError  = yyResult.select(yyError, yyRepetition1);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError, yyRepetition1);
                    if (yyResult.hasValue()) {

                      yyResult = p$$Shared4(yyResult.index);
                      yyError  = yyResult.select(yyError, yyRepetition1);
                      if (yyResult.hasValue()) {
                        Alias v$el$3 = yyResult.semanticValue();

                        yyRepetition1 = yyResult.index;
                        yyRepValue1   = new Pair<Alias>(v$el$3, yyRepValue1);
                        continue;
                      }
                    }
                  }
                }
                break;
              }
              { // Start scope for a2s.
                Pair<Alias> a2s = yyRepValue1.reverse();

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pclosecurly(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pfrom(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pw(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pStringLiteral(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            StringLiteral a3 = yyResult.semanticValue();

                            yyResult = pw(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = psemicolon(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                                Id module = new Id(info, a3.str());
                                yyValue = new ImportFrom(info, toList(cons(a1, a2s.list())), module.name());

                                return yyResult.createValue(yyValue, yyError);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } // End scope for a2s.
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared4.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.Alias and Declaration.Alias.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared4(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared4) 
      yyColumn.chunk1.f$$Shared4 = p$$Shared4$1(yyStart);
    return yyColumn.chunk1.f$$Shared4;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared4. */
  private Result p$$Shared4$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Id         yyOpValue1;
    Alias      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared31(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyResult = pas(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared31(yyResult.index);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              Id v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a2.
        Id a2 = yyOpValue1;

        ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
        Option<Id> alias;
        if (a2 == null) alias = Option.<Id>apply(null);
        else alias = Some.<Id>apply(a2);
        yyValue = new Alias(info, a1, alias);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared38.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.ContractDefinition 
   * and Declaration.ContractDefinition.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared38(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyOption1;
    Object             yyOpValue1;
    ContractDefinition yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared5(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      DefinitionKind a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared31(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyResult = pis(yyResult.index);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {

                yyResult = p$$Shared32(yyResult.index);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  List<InheritanceSpecifier> v$el$1 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$1;
                }
              }
            }
          }
          { // Start scope for a3.
            List<InheritanceSpecifier> a3 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = popencurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {

                  yyResult = p$$Shared37(yyResult.index);
                  yyError  = yyResult.select(yyError, yyOption1);
                  if (yyResult.hasValue()) {
                    List<ContractPart> v$el$2 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$2;
                  }
                }
                { // Start scope for a4.
                  List<ContractPart> a4 = cast(yyOpValue1);

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pclosecurly(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                      scala.collection.immutable.List<InheritanceSpecifier> supers;
                      if (a3 == null) supers = nilSupers;
                      else supers = toList(a3);
                      scala.collection.immutable.List<ContractPart> body;
                      if (a4 == null) body = nilCPs;
                      else body = toList(a4);
                      yyValue = new ContractDefinition(info, a1, a2, supers, body);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                } // End scope for a4.
              }
            }
          } // End scope for a3.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared5.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.DefinitionKind and Declaration.DefinitionKind.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared5(final int yyStart) throws IOException {
    Result         yyResult;
    DefinitionKind yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcontract(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ContractKind(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = plibrary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new LibraryKind(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pinterface(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new InterfaceKind(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared32.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.InheritanceSpecifierList 
   * and Declaration.InheritanceSpecifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared32(final int yyStart) throws IOException {
    Result                     yyResult;
    int                        yyRepetition1;
    Pair<InheritanceSpecifier> yyRepValue1;
    List<InheritanceSpecifier> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared25(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      InheritanceSpecifier a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyResult = p$$Shared25(yyResult.index);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {
                InheritanceSpecifier v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = 
                  new Pair<InheritanceSpecifier>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<InheritanceSpecifier> a2s = yyRepValue1.reverse();

        yyValue = cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared25.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.InheritanceSpecifier 
   * and Declaration.InheritanceSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared25(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared25) 
      yyColumn.chunk1.f$$Shared25 = p$$Shared25$1(yyStart);
    return yyColumn.chunk1.f$$Shared25;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared25. */
  private Result p$$Shared25$1(final int yyStart) throws IOException {
    Result               yyResult;
    int                  yyOption1;
    List<Expression>     yyOpValue1;
    InheritanceSpecifier yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUserDefinedTypeName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeName a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared17(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          List<Expression> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        List<Expression> a2 = yyOpValue1;

        ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
        scala.collection.immutable.List<Expression> args;
        if (a2 == null) args = nilExprs;
        else args = toList(a2);
        yyValue = new InheritanceSpecifier(info, a1, args);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared17.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.Expressions and Declaration.Expressions.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared17(final int yyStart) throws IOException {
    Result           yyResult;
    List<Expression> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = p$$Shared6(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyResult = pcloseparen(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = Collections.<Expression>emptyList();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared6.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.ExpressionList and Declaration.ExpressionList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared6(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared6) 
      yyColumn.chunk1.f$$Shared6 = p$$Shared6$1(yyStart);
    return yyColumn.chunk1.f$$Shared6;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared6. */
  private Result p$$Shared6$1(final int yyStart) throws IOException {
    Result           yyResult;
    List<Expression> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyResult = p$$Shared6$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Expression> a2s = yyResult.semanticValue();

        yyValue = cons(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared6$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared6$$Star1(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared6$$Star1) 
      yyColumn.chunk1.f$$Shared6$$Star1 = p$$Shared6$$Star1$1(yyStart);
    return yyColumn.chunk1.f$$Shared6$$Star1;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared6$$Star1. */
  private Result p$$Shared6$$Star1$1(final int yyStart) throws IOException {
    Result           yyResult;
    Pair<Expression> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expression v$el$1 = yyResult.semanticValue();

            yyResult = p$$Shared6$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Expression> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Expression>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared37.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.ContractPartList 
   * and Declaration.ContractPartList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared37(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<ContractPart> yyRepValue1;
    List<ContractPart> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared36(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ContractPart a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared36(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            ContractPart v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<ContractPart>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<ContractPart> a2s = yyRepValue1.reverse();

        yyValue = cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared36.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.ContractPart and Declaration.ContractPart.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared36(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared36) 
      yyColumn.chunk1.f$$Shared36 = p$$Shared36$1(yyStart);
    return yyColumn.chunk1.f$$Shared36;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared36. */
  private Result p$$Shared36$1(final int yyStart) throws IOException {
    Result       yyResult;
    ContractPart yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared26(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = p$$Shared7(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = p$$Shared27(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = p$$Shared33(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = p$$Shared35(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = p$$Shared29(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = p$$Shared21(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared26.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.StateVariableDeclaration 
   * and Declaration.StateVariableDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared26(final int yyStart) throws IOException {
    Result                   yyResult;
    int                      yyOption1;
    Object                   yyOpValue1;
    StateVariableDeclaration yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypeName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeName a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared23(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          List<Mod> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        List<Mod> a2 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared31(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Id a3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {

              yyResult = pequals(yyResult.index);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {

                  yyResult = pExpression(yyResult.index);
                  yyError  = yyResult.select(yyError, yyOption1);
                  if (yyResult.hasValue()) {
                    Expression v$el$2 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$2;
                  }
                }
              }
            }
            { // Start scope for a4.
              Expression a4 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = psemicolon(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                  scala.collection.immutable.List<Mod> mods;
                  if (a2 == null) mods = nilMods;
                  else mods = toList(a2);
                  Option<Expression> body;
                  if (a4 == null) body = Option.<Expression>apply(null);
                  else body = Some.<Expression>apply(a4);
                  yyValue = new StateVariableDeclaration(info, a1, mods, a3, body);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } // End scope for a4.
          }
        }
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared7.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.UsingForDeclaration 
   * and Declaration.UsingForDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared7(final int yyStart) throws IOException {
    Result              yyResult;
    UsingForDeclaration yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pusing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared31(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pfor(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                final int yyChoice1 = yyResult.index;

                // Nested alternative 1.

                yyResult = pstar(yyChoice1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = psemicolon(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                      yyValue = new UsingForDeclaration(info, a1, "*");

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }

                // Nested alternative 2.

                yyResult = pTypeName(yyChoice1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  TypeName a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = psemicolon(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                      yyValue = new UsingForDeclaration(info, a1, a2.toString(0));

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared27.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.StructDefinition 
   * and Declaration.StructDefinition.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared27(final int yyStart) throws IOException {
    Result           yyResult;
    StructDefinition yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pstruct(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared31(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = popencurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                final int yyChoice1 = yyResult.index;

                // Nested alternative 1.

                yyResult = pclosecurly(yyChoice1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                  yyValue = new StructDefinition(info, a1, nilVDs);

                  return yyResult.createValue(yyValue, yyError);
                }

                // Nested alternative 2.

                yyResult = p$$Shared18(yyChoice1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<VariableDeclaration> a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pclosecurly(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                      yyValue = new StructDefinition(info, a1, toList(a2));

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared18.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.VariableDeclarationList 
   * and Declaration.VariableDeclarationList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared18(final int yyStart) throws IOException {
    Result                    yyResult;
    int                       yyRepetition1;
    Pair<VariableDeclaration> yyRepValue1;
    List<VariableDeclaration> yyValue;
    ParseError                yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      VariableDeclaration a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = psemicolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyResult = p$$Shared8(yyResult.index);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {
                VariableDeclaration v$el$1 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError, yyRepetition1);
                if (yyResult.hasValue()) {

                  yyResult = psemicolon(yyResult.index);
                  yyError  = yyResult.select(yyError, yyRepetition1);
                  if (yyResult.hasValue()) {

                    yyRepetition1 = yyResult.index;
                    yyRepValue1   = 
                      new Pair<VariableDeclaration>(v$el$1, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }
          { // Start scope for a2s.
            Pair<VariableDeclaration> a2s = yyRepValue1.reverse();

            yyValue = cons(a1, a2s.list());

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for a2s.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared8.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.VariableDeclaration 
   * and Declaration.VariableDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared8(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.f$$Shared8) 
      yyColumn.chunk2.f$$Shared8 = p$$Shared8$1(yyStart);
    return yyColumn.chunk2.f$$Shared8;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared8. */
  private Result p$$Shared8$1(final int yyStart) throws IOException {
    Result              yyResult;
    VariableDeclaration yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypeName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeName a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pStorageLocation(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          StorageLocation a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared31(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id a3 = yyResult.semanticValue();

              ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
              yyValue = new VariableDeclaration(info, a1, Some.<StorageLocation>apply(a2), a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyResult = pcalldata(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
          yyValue = new VariableDeclaration(info, a1, Option.<StorageLocation>apply(null),
          new Id(info, "calldata"));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = p$$Shared31(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a2 = yyResult.semanticValue();

          ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
          yyValue = new VariableDeclaration(info, a1, Option.<StorageLocation>apply(null), a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared33.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.ModifierDefinition 
   * and Declaration.ModifierDefinition.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared33(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyOption1;
    List<Parameter>    yyOpValue1;
    ModifierDefinition yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pmodifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared31(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared28(yyResult.index);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              List<Parameter> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<Parameter> a2 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pBlock(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<Statement> a3 = yyResult.semanticValue();

                ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                scala.collection.immutable.List<Parameter> params;
                if (a2 == null) params = nilParams;
                else params = toList(a2);
                yyValue = new ModifierDefinition(info, a1, params, toList(a3));

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared28.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.Params and Declaration.Params.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared28(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.f$$Shared28) 
      yyColumn.chunk2.f$$Shared28 = p$$Shared28$1(yyStart);
    return yyColumn.chunk2.f$$Shared28;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared28. */
  private Result p$$Shared28$1(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    List<Parameter> yyOpValue1;
    List<Parameter> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared19(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          List<Parameter> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<Parameter> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            if (a1 == null) yyValue = Collections.<Parameter>emptyList();
            else yyValue = a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared19.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.ParameterList and Declaration.ParameterList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared19(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyRepetition1;
    Pair<Parameter> yyRepValue1;
    List<Parameter> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared9(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Parameter a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyResult = p$$Shared9(yyResult.index);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {
                Parameter v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Parameter>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Parameter> a2s = yyRepValue1.reverse();

        yyValue = cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared9.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.Parameter and Declaration.Parameter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared9(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.f$$Shared9) 
      yyColumn.chunk2.f$$Shared9 = p$$Shared9$1(yyStart);
    return yyColumn.chunk2.f$$Shared9;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared9. */
  private Result p$$Shared9$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Parameter  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypeName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeName a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyResult = pStorageLocation(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          StorageLocation v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        StorageLocation a2 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared31(yyResult.index);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            Id v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a3.
          Id a3 = cast(yyOpValue1);

          ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
          Option<StorageLocation> loc;
          if (a2 == null) loc = Option.<StorageLocation>apply(null);
          else loc = Some.<StorageLocation>apply(a2);
          Option<Id> name;
          if (a3 == null) name = Option.<Id>apply(null);
          else name = Some.<Id>apply(a3);
          yyValue = new Parameter(info, a1, loc, name);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared35.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.FunctionDefinition 
   * and Declaration.FunctionDefinition.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared35(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyOption1;
    Object             yyOpValue1;
    FunctionDefinition yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pfunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared31(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          Id v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        Id a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared28(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Parameter> a2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {

              yyResult = p$$Shared34(yyResult.index);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                List<FtnMod> v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
            { // Start scope for a3.
              List<FtnMod> a3 = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {

                yyResult = preturns(yyResult.index);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError, yyOption1);
                  if (yyResult.hasValue()) {

                    yyResult = p$$Shared28(yyResult.index);
                    yyError  = yyResult.select(yyError, yyOption1);
                    if (yyResult.hasValue()) {
                      List<Parameter> v$el$3 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$3;
                    }
                  }
                }
              }
              { // Start scope for a4.
                List<Parameter> a4 = cast(yyOpValue1);

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  final int yyChoice1 = yyResult.index;

                  // Nested alternative 1.

                  yyResult = psemicolon(yyChoice1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                    Option<Id> name;
                    if (a1 == null) name = Option.<Id>apply(null);
                    else name = Some.<Id>apply(a1);
                    scala.collection.immutable.List<FtnMod> mods;
                    if (a3 == null) mods = nilFtnMods;
                    else mods = toList(a3);
                    scala.collection.immutable.List<Parameter> result;
                    if (a4 == null) result = nilParams;
                    else result = toList(a4);
                    yyValue = new FunctionDefinition(info, name, toList(a2), mods, result, nilStmts, comment);
                    comment = "";

                    return yyResult.createValue(yyValue, yyError);
                  }

                  // Nested alternative 2.

                  yyResult = pBlock(yyChoice1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    List<Statement> a5 = yyResult.semanticValue();

                    ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                    Option<Id> name;
                    if (a1 == null) name = Option.<Id>apply(null);
                    else name = Some.<Id>apply(a1);
                    scala.collection.immutable.List<FtnMod> mods;
                    if (a3 == null) mods = nilFtnMods;
                    else mods = toList(a3);
                    scala.collection.immutable.List<Parameter> result;
                    if (a4 == null) result = nilParams;
                    else result = toList(a4);
                    yyValue = new FunctionDefinition(info, name, toList(a2), mods, result, toList(a5), comment);
                    comment = "";

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for a4.
            } // End scope for a3.
          }
        }
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = pconstructor(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared28(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Parameter> a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared34(yyResult.index);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              List<FtnMod> v$el$4 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$4;
            }
          }
          { // Start scope for a2.
            List<FtnMod> a2 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pBlock(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<Statement> a3 = yyResult.semanticValue();

                ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                Option<Id> name = Some.<Id>apply(new Id(info, "constructor"));
                scala.collection.immutable.List<FtnMod> mods;
                if (a2 == null) mods = nilFtnMods;
                else mods = toList(a2);
                yyValue = new FunctionDefinition(info, name, toList(a1), mods, nilParams, toList(a3), comment);
                comment = "";

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared29.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.EventDefinition 
   * and Declaration.EventDefinition.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared29(final int yyStart) throws IOException {
    Result               yyResult;
    int                  yyOption1;
    List<EventParameter> yyOpValue1;
    EventDefinition      yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pevent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared31(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = popenparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {

                yyResult = p$$Shared20(yyResult.index);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  List<EventParameter> v$el$1 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$1;
                }
              }
              { // Start scope for a2.
                List<EventParameter> a2 = yyOpValue1;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption1  = yyResult.index;

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError, yyOption1);
                    if (yyResult.hasValue()) {

                      yyResult = panonymous(yyResult.index);
                      yyError  = yyResult.select(yyError, yyOption1);
                      if (yyResult.hasValue()) {

                        yyOption1  = yyResult.index;
                      }
                    }

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = psemicolon(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                        scala.collection.immutable.List<EventParameter> params;
                        if (a2 == null) params = nilEventParams;
                        else params = toList(a2);
                        yyValue = new EventDefinition(info, a1, params);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }
              } // End scope for a2.
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared20.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.EventParameterList 
   * and Declaration.EventParameterList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared20(final int yyStart) throws IOException {
    Result               yyResult;
    int                  yyRepetition1;
    Pair<EventParameter> yyRepValue1;
    List<EventParameter> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared10(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      EventParameter a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyResult = p$$Shared10(yyResult.index);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {
                EventParameter v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<EventParameter>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<EventParameter> a2s = yyRepValue1.reverse();

        yyValue = cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared10.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.EventParameter and Declaration.EventParameter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared10(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.f$$Shared10) 
      yyColumn.chunk2.f$$Shared10 = p$$Shared10$1(yyStart);
    return yyColumn.chunk2.f$$Shared10;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared10. */
  private Result p$$Shared10$1(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    Id             yyOpValue1;
    EventParameter yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypeName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeName a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyResult = pindexed(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }
      }

      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared31(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          Id v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        Id a2 = yyOpValue1;

        ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
        Option<Id> name;
        if (a2 == null) name = Option.<Id>apply(null);
        else name = Some.<Id>apply(a2);
        yyValue = new EventParameter(info, a1, name);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared21.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.EnumDefinition and Declaration.EnumDefinition.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared21(final int yyStart) throws IOException {
    Result         yyResult;
    EnumDefinition yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = penum(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared31(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = popencurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                final int yyChoice1 = yyResult.index;

                // Nested alternative 1.

                yyResult = pclosecurly(yyChoice1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                  yyValue = new EnumDefinition(info, a1, nilIds);

                  return yyResult.createValue(yyValue, yyError);
                }

                // Nested alternative 2.

                yyResult = p$$Shared11(yyChoice1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Id> a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pclosecurly(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                      yyValue = new EnumDefinition(info, a1, toList(a2));

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared11.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.EnumValueList, Declaration.EnumValueList, 
   * and Literal.IdList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared11(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.f$$Shared11) 
      yyColumn.chunk2.f$$Shared11 = p$$Shared11$1(yyStart);
    return yyColumn.chunk2.f$$Shared11;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared11. */
  private Result p$$Shared11$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared31(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = p$$Shared11$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Id> a2s = yyResult.semanticValue();

        yyValue = cons(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared11$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared11$$Star1(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.f$$Shared11$$Star1) 
      yyColumn.chunk2.f$$Shared11$$Star1 = p$$Shared11$$Star1$1(yyStart);
    return yyColumn.chunk2.f$$Shared11$$Star1;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared11$$Star1. */
  private Result p$$Shared11$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared31(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Id v$el$1 = yyResult.semanticValue();

            yyResult = p$$Shared11$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Id> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Id>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared34.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.FtnMods and Declaration.FtnMods.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared34(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.f$$Shared34) 
      yyColumn.chunk2.f$$Shared34 = p$$Shared34$1(yyStart);
    return yyColumn.chunk2.f$$Shared34;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared34. */
  private Result p$$Shared34$1(final int yyStart) throws IOException {
    Result       yyResult;
    List<FtnMod> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared30(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      FtnMod a1 = yyResult.semanticValue();

      yyResult = p$$Shared34$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<FtnMod> a2s = yyResult.semanticValue();

        yyValue = cons(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared34$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared34$$Star1(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.f$$Shared34$$Star1) 
      yyColumn.chunk2.f$$Shared34$$Star1 = p$$Shared34$$Star1$1(yyStart);
    return yyColumn.chunk2.f$$Shared34$$Star1;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared34$$Star1. */
  private Result p$$Shared34$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<FtnMod> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = p$$Shared30(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        FtnMod v$el$1 = yyResult.semanticValue();

        yyResult = p$$Shared34$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<FtnMod> v$2 = yyResult.semanticValue();

          yyValue = new Pair<FtnMod>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared30.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.FtnMod and Declaration.FtnMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared30(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.f$$Shared30) 
      yyColumn.chunk2.f$$Shared30 = p$$Shared30$1(yyStart);
    return yyColumn.chunk2.f$$Shared30;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared30. */
  private Result p$$Shared30$1(final int yyStart) throws IOException {
    Result     yyResult;
    FtnMod     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared22(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pStateMutability(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pexternal(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new External(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pinternal(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Internal(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pprivate(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Private(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = ppublic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Public(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared22.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.ModifierInvocation 
   * and Declaration.ModifierInvocation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared22(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyOption1;
    List<Expression>   yyOpValue1;
    ModifierInvocation yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared31(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popenparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared6(yyResult.index);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              List<Expression> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<Expression> a2 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                scala.collection.immutable.List<Expression> exprs;
                if (a2 == null) exprs = nilExprs;
                else exprs = toList(a2);
                yyValue = new ModifierInvocation(info, a1, exprs);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a2.
        }
      }

      // Nested alternative 2.

      ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
      yyValue = new ModifierInvocation(info, a1, nilExprs);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared23.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.ModList and Declaration.ModList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared23(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Mod>  yyRepValue1;
    List<Mod>  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared12(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Mod a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared12(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            Mod v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Mod>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Mod> a2s = yyRepValue1.reverse();

        yyValue = cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared12.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.saf.parser.SOL.Mod and Declaration.Mod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared12(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.f$$Shared12) 
      yyColumn.chunk2.f$$Shared12 = p$$Shared12$1(yyStart);
    return yyColumn.chunk2.f$$Shared12;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.$$Shared12. */
  private Result p$$Shared12$1(final int yyStart) throws IOException {
    Result     yyResult;
    Mod        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pconstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Constant(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pexternal(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new External(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pinternal(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Internal(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pprivate(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Private(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = ppublic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Public(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = ppayable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Payable(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.File.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDeclaration$File(final int yyStart) throws IOException {
    Result              yyResult;
    int                 yyOption1;
    List<SourceElement> yyOpValue1;
    SourceUnit          yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = p$$Shared40(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        List<SourceElement> v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for a2.
        List<SourceElement> a2 = yyOpValue1;

        yyResult = p$$Shared2(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          Span span = createSpan(yyStart,yyCount);
          ASTNodeInfo info = NodeUtil.makeASTNodeInfo(span);
          scala.collection.immutable.List<SourceElement> ses;
          if (a2 == null) ses = nilSes;
          else ses = toList(a2);
          HashMap<String, Span> map = new HashMap<String, Span>();
          yyValue = new SourceUnit(info, ses);

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.Block.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlock(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyRepetition1;
    Pair<Statement> yyRepValue1;
    List<Statement> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pclosecurly(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = list();

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pStatement(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Statement a1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyResult = pStatement(yyResult.index);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {
                Statement v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Statement>(v$el$1, yyRepValue1);
                continue;
              }
            }
            break;
          }
          { // Start scope for a2s.
            Pair<Statement> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a2s.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.Statement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatement(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fStatement) 
      yyColumn.chunk3.fStatement = pStatement$1(yyStart);
    return yyColumn.chunk3.fStatement;
  }

  /** Actually parse Statement.Statement. */
  private Result pStatement$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Statement  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pfunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared31(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          Id v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        Id a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared28(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Parameter> a2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {

              yyResult = p$$Shared34(yyResult.index);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                List<FtnMod> v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
            { // Start scope for a3.
              List<FtnMod> a3 = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {

                yyResult = preturns(yyResult.index);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError, yyOption1);
                  if (yyResult.hasValue()) {

                    yyResult = p$$Shared28(yyResult.index);
                    yyError  = yyResult.select(yyError, yyOption1);
                    if (yyResult.hasValue()) {
                      List<Parameter> v$el$3 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$3;
                    }
                  }
                }
              }
              { // Start scope for a4.
                List<Parameter> a4 = cast(yyOpValue1);

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pequals(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pStatement(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Statement a5 = yyResult.semanticValue();

                        ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                        Option<Id> name;
                        if (a1 == null) name = Option.<Id>apply(null);
                        else name = Some.<Id>apply(a1);
                        scala.collection.immutable.List<FtnMod> mods;
                        if (a3 == null) mods = nilFtnMods;
                        else mods = toList(a3);
                        scala.collection.immutable.List<Parameter> result;
                        if (a4 == null) result = nilParams;
                        else result = toList(a4);
                        yyValue = new FtnDefStmt(info, name, toList(a2), mods, result, a5);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }
              } // End scope for a4.
            } // End scope for a3.
          }
        }
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = pif(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popenparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expression a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcloseparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pStatement(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Statement a2 = yyResult.semanticValue();

                      final int yyChoice1 = yyResult.index;

                      // Nested alternative 1.

                      yyResult = pw(yyChoice1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pelse(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pStatement(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              Statement a3 = yyResult.semanticValue();

                              Span span = createSpan(yyStart,yyCount);
                              yyValue = new If(NodeUtil.makeASTNodeInfo(span), a1, a2, Some.<Statement>apply(a3));

                              return yyResult.createValue(yyValue, yyError);
                            }
                          }
                        }
                      }

                      // Nested alternative 2.

                      Span span = createSpan(yyStart,yyCount);
                      yyValue = new If(NodeUtil.makeASTNodeInfo(span), a1, a2, Option.<Statement>apply(null));

                      return new SemanticValue(yyValue, yyChoice1, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 3.

    yyResult = pwhile(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popenparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expression a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcloseparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pStatement(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Statement a2 = yyResult.semanticValue();

                      Span span = createSpan(yyStart,yyCount);
                      yyValue = new While(NodeUtil.makeASTNodeInfo(span), a1, a2);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pfor(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popenparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyResult = pSimpleStatement(yyResult.index);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              SimpleStatement v$el$4 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$4;
            }
          }
          { // Start scope for a1.
            SimpleStatement a1 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = psemicolon(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {

                  yyResult = pExpression(yyResult.index);
                  yyError  = yyResult.select(yyError, yyOption1);
                  if (yyResult.hasValue()) {
                    Expression v$el$5 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$5;
                  }
                }
                { // Start scope for a2.
                  Expression a2 = cast(yyOpValue1);

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = psemicolon(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError, yyOption1);
                      if (yyResult.hasValue()) {

                        yyResult = pExpressionStatement(yyResult.index);
                        yyError  = yyResult.select(yyError, yyOption1);
                        if (yyResult.hasValue()) {
                          ExprStmt v$el$6 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$6;
                        }
                      }
                      { // Start scope for a3.
                        ExprStmt a3 = cast(yyOpValue1);


                        yyResult = pw(yyOption1);
                        yyError  = yyResult.select(yyError, yyOption1);
                        if (yyResult.hasValue()) {

                          yyResult = psemicolon(yyResult.index);
                          yyError  = yyResult.select(yyError, yyOption1);
                          if (yyResult.hasValue()) {

                            yyOption1  = yyResult.index;
                          }
                        }

                        yyResult = pw(yyOption1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pcloseparen(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pw(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = pStatement(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {
                                Statement a4 = yyResult.semanticValue();

                                Span span = createSpan(yyStart,yyCount);
                                Option<SimpleStatement> init;
                                Option<Expression> test;
                                Option<Statement> update;
                                if (a1 == null) init = Option.<SimpleStatement>apply(null);
                                else            init = Some.<SimpleStatement>apply(a1);
                                if (a2 == null) test = Option.<Expression>apply(null);
                                else            test = Some.<Expression>apply(a2);
                                if (a3 == null) update = Option.<Statement>apply(null);
                                else            update = Some.<Statement>apply(a3);
                                yyValue = new For(NodeUtil.makeASTNodeInfo(span), init, test, update, a4);

                                return yyResult.createValue(yyValue, yyError);
                              }
                            }
                          }
                        }
                      } // End scope for a3.
                    }
                  }
                } // End scope for a2.
              }
            }
          } // End scope for a1.
        }
      }
    }

    // Alternative 5.

    yyResult = pBlock(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Statement> a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount+1);
      yyValue = new ABlock(NodeUtil.makeASTNodeInfo(span), toList(a1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = passembly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyResult = pStringLiteral(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          StringLiteral v$el$7 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$7;
        }
      }
      { // Start scope for a1.
        StringLiteral a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pInlineAssemblyBlock(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<AssemblyItem> a2 = yyResult.semanticValue();

            Span span = createSpan(yyStart,yyCount+1);
            Option<String> name;
            if (a1 == null) name = Option.<String>apply(null);
            else            name = Some.<String>apply(a1.str());
            yyValue = new InlineAssembly(NodeUtil.makeASTNodeInfo(span), name, toList(a2));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Alternative 7.

    yyResult = pdo(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStatement(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Statement a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pwhile(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = popenparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pExpression(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Expression a2 = yyResult.semanticValue();

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pcloseparen(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = psemicolon(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              Span span = createSpan(yyStart,yyCount);
                              yyValue = new DoWhile(NodeUtil.makeASTNodeInfo(span), a1, a2);

                              return yyResult.createValue(yyValue, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 8.

    yyResult = pcontinue(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = psemicolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
          yyValue = new Continue(info);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 9.

    yyResult = pbreak(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = psemicolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          Span span = createSpan(yyStart,yyCount);
          yyValue = new Break(NodeUtil.makeASTNodeInfo(span));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 10.

    yyResult = preturn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = psemicolon(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              Span span = createSpan(yyStart,yyCount);
              yyValue = new Return(NodeUtil.makeASTNodeInfo(span), Some.<Expression>apply(a1));

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyResult = psemicolon(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          Span span = createSpan(yyStart,yyCount);
          yyValue = new Return(NodeUtil.makeASTNodeInfo(span), Option.<Expression>apply(null));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 11.

    yyResult = pthrow(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = psemicolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          Span span = createSpan(yyStart,yyCount);
          yyValue = new Throw(NodeUtil.makeASTNodeInfo(span));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 12.

    yyResult = pemit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pCallExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = psemicolon(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              Span span = createSpan(yyStart,yyCount);
              yyValue = new Emit(NodeUtil.makeASTNodeInfo(span), a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 13.

    yyResult = pSimpleStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = psemicolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 14.

    yyResult = punderscore(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyResult = psemicolon(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }
      }

      Span span = createSpan(yyStart,yyCount);
      yyValue = new Underscore(NodeUtil.makeASTNodeInfo(span));

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.SimpleStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleStatement(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fSimpleStatement) 
      yyColumn.chunk3.fSimpleStatement = pSimpleStatement$1(yyStart);
    return yyColumn.chunk3.fSimpleStatement;
  }

  /** Actually parse Statement.SimpleStatement. */
  private Result pSimpleStatement$1(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    Object          yyOpValue1;
    SimpleStatement yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pvar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pOptIds(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Option<Id>> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pInitBody(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expression a2 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              yyValue = new SimpleVarX(NodeUtil.makeASTNodeInfo(span), toList(a1), a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyResult = p$$Shared31(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyResult = pInitBody(yyResult.index);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              Expression v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            Expression a2 = cast(yyOpValue1);

            Span span = createSpan(yyStart,yyCount);
            Option<Expression> body;
            if (a2 == null) body = Option.<Expression>apply(null);
            else            body = Some.<Expression>apply(a2);
            yyValue = new SimpleVar(NodeUtil.makeASTNodeInfo(span), a1, body);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a2.
        }
      }
    }

    // Alternative 2.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      VariableDeclaration a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyResult = pInitBody(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          Expression v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a2.
        Expression a2 = cast(yyOpValue1);

        Span span = createSpan(yyStart,yyCount);
        Option<Expression> body;
        if (a2 == null) body = Option.<Expression>apply(null);
        else            body = Some.<Expression>apply(a2);
        yyValue = new VarDecl(NodeUtil.makeASTNodeInfo(span), toList(list(a1)), body);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Alternative 3.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyResult = pStatement$VariableDeclarationList(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          List<VariableDeclaration> v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
      }
      { // Start scope for a1.
        List<VariableDeclaration> a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {

              yyResult = pInitBody(yyResult.index);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                Expression v$el$4 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$4;
              }
            }
            { // Start scope for a2.
              Expression a2 = cast(yyOpValue1);

              Span span = createSpan(yyStart,yyCount);
              scala.collection.immutable.List<VariableDeclaration> decs;
              if (a1 == null) decs = nilVDs;
              else            decs = toList(a1);
              Option<Expression> body;
              if (a2 == null) body = Option.<Expression>apply(null);
              else            body = Some.<Expression>apply(a2);
              yyValue = new VarDecl(NodeUtil.makeASTNodeInfo(span), decs, body);

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for a2.
          }
        }
      } // End scope for a1.
    }

    // Alternative 4.

    yyResult = pExpressionStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.VariableDeclarationList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatement$VariableDeclarationList(final int yyStart) 
    throws IOException {

    Result                    yyResult;
    int                       yyRepetition1;
    Pair<VariableDeclaration> yyRepValue1;
    int                       yyRepetition2;
    List<VariableDeclaration> yyValue;
    ParseError                yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pcomma(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
      }
      break;
    }

    yyResult = p$$Shared8(yyRepetition1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      VariableDeclaration a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyRepetition2 = yyResult.index;
          while (true) {

            yyResult = pcomma(yyRepetition2);
            yyError  = yyResult.select(yyError, yyRepetition2);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError, yyRepetition2);
              if (yyResult.hasValue()) {

                yyRepetition2 = yyResult.index;
                continue;
              }
            }
            break;
          }

          yyResult = p$$Shared8(yyRepetition2);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            VariableDeclaration v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = 
              new Pair<VariableDeclaration>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<VariableDeclaration> a2s = yyRepValue1.reverse();

        while (true) {

          yyResult = pw(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyResult = pcomma(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              continue;
            }
          }
          break;
        }

        yyValue = cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.InitBody.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInitBody(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fInitBody) 
      yyColumn.chunk3.fInitBody = pInitBody$1(yyStart);
    return yyColumn.chunk3.fInitBody;
  }

  /** Actually parse Statement.InitBody. */
  private Result pInitBody$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pequals(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.ExpressionStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpressionStatement(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExpressionStatement) 
      yyColumn.chunk3.fExpressionStatement = pExpressionStatement$1(yyStart);
    return yyColumn.chunk3.fExpressionStatement;
  }

  /** Actually parse Statement.ExpressionStatement. */
  private Result pExpressionStatement$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    ExprStmt   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = new ExprStmt(NodeUtil.makeASTNodeInfo(span), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.InlineAssemblyBlock.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInlineAssemblyBlock(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fInlineAssemblyBlock) 
      yyColumn.chunk3.fInlineAssemblyBlock = pInlineAssemblyBlock$1(yyStart);
    return yyColumn.chunk3.fInlineAssemblyBlock;
  }

  /** Actually parse Statement.InlineAssemblyBlock. */
  private Result pInlineAssemblyBlock$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    List<AssemblyItem> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pAssemblyItems(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyResult = pclosecurly(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = Collections.<AssemblyItem>emptyList();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.AssemblyItems.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssemblyItems(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<AssemblyItem> yyRepValue1;
    List<AssemblyItem> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAssemblyItem(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AssemblyItem a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyResult = pAssemblyItem(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            AssemblyItem v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<AssemblyItem>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<AssemblyItem> a2s = yyRepValue1.reverse();

        yyValue = cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.AssemblyItem.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssemblyItem(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fAssemblyItem) 
      yyColumn.chunk3.fAssemblyItem = pAssemblyItem$1(yyStart);
    return yyColumn.chunk3.fAssemblyItem;
  }

  /** Actually parse Statement.AssemblyItem. */
  private Result pAssemblyItem$1(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    int          yyBase;
    int          yyOption1;
    Object       yyOpValue1;
    int          yyOption2;
    AssemblyItem yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInlineAssemblyBlock(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<AssemblyItem> a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = new AssemblyBlock(NodeUtil.makeASTNodeInfo(span), toList(a1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = plet(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdOrList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Id> a1 = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyResult = pw(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if (':' == yyC) {
              yyIndex = yyResult.index + 1;

              yyResult = pw(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyBase = yyResult.index;
                yyC    = character(yyBase);
                if ('=' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyResult = pw(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pAssemblyExpression(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      AssemblyExpression a2 = yyResult.semanticValue();

                      Span span = createSpan(yyStart,yyCount);
                      yyValue = new AssemblyLetX(NodeUtil.makeASTNodeInfo(span), toList(a1), a2);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                } else {
                  yyError = yyError.select("'=' expected", yyBase);
                }
              }
            } else {
              yyError = yyError.select("':' expected", yyBase);
            }
          }

          // Nested alternative 2.

          yyOption1  = yyChoice1;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if (':' == yyC) {
              yyIndex = yyResult.index + 1;

              yyResult = pw(yyIndex);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {

                yyBase = yyResult.index;
                yyC    = character(yyBase);
                if ('=' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyResult = pw(yyIndex);
                  yyError  = yyResult.select(yyError, yyOption1);
                  if (yyResult.hasValue()) {

                    yyResult = pFunctionalAssemblyExpression(yyResult.index);
                    yyError  = yyResult.select(yyError, yyOption1);
                    if (yyResult.hasValue()) {
                      FtnAssembly v$el$1 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$1;
                    }
                  }
                } else {
                  yyError = yyError.select("'=' expected", yyBase);
                }
              }
            } else {
              yyError = yyError.select("':' expected", yyBase);
            }
          }
          { // Start scope for a2.
            FtnAssembly a2 = cast(yyOpValue1);

            Span span = createSpan(yyStart,yyCount);
            Option<FtnAssembly> body;
            if (a2 == null) body = Option.<FtnAssembly>apply(null);
            else            body = Some.<FtnAssembly>apply(a2);
            yyValue = new AssemblyLet(NodeUtil.makeASTNodeInfo(span), toList(a1), body);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a2.
        }
      }
    }

    // Alternative 3.

    yyResult = pif(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAssemblyExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          AssemblyExpression a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pInlineAssemblyBlock(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<AssemblyItem> a2 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              yyValue = new AssemblyIf(NodeUtil.makeASTNodeInfo(span), a1, toList(a2));

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pswitch(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAssemblyExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          AssemblyExpression a1 = yyResult.semanticValue();

          yyResult = pAssemblyItem$$Star1(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<AssemblyCase> a2s = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {

              yyResult = pdefault(yyResult.index);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {

                  yyResult = pInlineAssemblyBlock(yyResult.index);
                  yyError  = yyResult.select(yyError, yyOption1);
                  if (yyResult.hasValue()) {
                    List<AssemblyItem> v$el$4 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$4;
                  }
                }
              }
            }
            { // Start scope for a3.
              List<AssemblyItem> a3 = cast(yyOpValue1);

              ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
              scala.collection.immutable.List<AssemblyCase> cases;
              if (a2s == null) cases = nilACs;
              else             cases = toList(a2s.list());
              scala.collection.immutable.List<AssemblyItem> defB;
              if (a3 == null) defB = nilAIs;
              else            defB = toList(a3);
              yyValue = new AssemblySwitch(info, a1, cases, defB);

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for a3.
          }
        }
      }
    }

    // Alternative 5.

    yyResult = pfunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared31(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = popenparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {

                yyResult = p$$Shared11(yyResult.index);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  List<Id> v$el$5 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$5;
                }
              }
              { // Start scope for a2.
                List<Id> a2 = cast(yyOpValue1);

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption1  = yyResult.index;

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError, yyOption1);
                    if (yyResult.hasValue()) {

                      yyBase = yyResult.index;
                      yyC    = character(yyBase);
                      if ('-' == yyC) {
                        yyIndex = yyResult.index + 1;

                        yyC = character(yyIndex);
                        if ('>' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyOption2  = yyIndex;

                          yyResult = pw(yyOption2);
                          yyError  = yyResult.select(yyError, yyOption2);
                          if (yyResult.hasValue()) {

                            yyResult = popenparen(yyResult.index);
                            yyError  = yyResult.select(yyError, yyOption2);
                            if (yyResult.hasValue()) {

                              yyOption2  = yyResult.index;
                            }
                          }

                          yyResult = pw(yyOption2);
                          yyError  = yyResult.select(yyError, yyOption1);
                          if (yyResult.hasValue()) {

                            yyResult = p$$Shared31(yyResult.index);
                            yyError  = yyResult.select(yyError, yyOption1);
                            if (yyResult.hasValue()) {

                              yyOption2  = yyResult.index;

                              yyResult = pw(yyOption2);
                              yyError  = yyResult.select(yyError, yyOption2);
                              if (yyResult.hasValue()) {

                                yyResult = pcloseparen(yyResult.index);
                                yyError  = 
                                  yyResult.select(yyError, yyOption2);
                                if (yyResult.hasValue()) {

                                  yyOption2  = yyResult.index;
                                }
                              }

                              yyOption1  = yyOption2;
                            }
                          }
                        } else {
                          yyError = yyError.select("'->' expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("'->' expected", yyBase);
                      }
                    }

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pInlineAssemblyBlock(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        List<AssemblyItem> a3 = yyResult.semanticValue();

                        ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                        Option<Id> param;
                        if (a2 == null) param = Option.<Id>apply(null);
                        else            param = Some.<Id>apply(a2.get(0));
                        yyValue = new AssemblyFtn(info, a1, param, toList(a3));

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }
              } // End scope for a2.
            }
          }
        }
      }
    }

    // Alternative 6.

    yyResult = pfor(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pInlineAssemblyBlock(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<AssemblyItem> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pAssemblyExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              AssemblyExpression a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                final int yyChoice2 = yyResult.index;

                // Nested alternative 1.

                yyResult = pInlineAssemblyBlock(yyChoice2);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<AssemblyItem> a3 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pInlineAssemblyBlock(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<AssemblyItem> a4 = yyResult.semanticValue();

                      ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                      yyValue = new AssemblyFor(info, toList(a1), a2, toList(a3), toList(a4));

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }

                // Nested alternative 2.

                yyResult = pAssemblyExpression(yyChoice2);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  AssemblyExpression a3 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pInlineAssemblyBlock(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<AssemblyItem> a4 = yyResult.semanticValue();

                      ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                      yyValue = new AssemblyFor(info, toList(a1), a2, toList(list(new AssemblyExprStmt(info, a3))), toList(a4));

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }

        // Nested alternative 2.

        yyResult = pAssemblyExpression(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          AssemblyExpression a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pAssemblyExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              AssemblyExpression a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                final int yyChoice2 = yyResult.index;

                // Nested alternative 1.

                yyResult = pInlineAssemblyBlock(yyChoice2);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<AssemblyItem> a3 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pInlineAssemblyBlock(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<AssemblyItem> a4 = yyResult.semanticValue();

                      ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                      yyValue = new AssemblyFor(info, toList(list(new AssemblyExprStmt(info, a1))), a2, toList(a3), toList(a4));

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }

                // Nested alternative 2.

                yyResult = pAssemblyExpression(yyChoice2);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  AssemblyExpression a3 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pInlineAssemblyBlock(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<AssemblyItem> a4 = yyResult.semanticValue();

                      ASTNodeInfo info = NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount));
                      yyValue = new AssemblyFor(info, toList(list(new AssemblyExprStmt(info, a1))),
                      a2, toList(list(new AssemblyExprStmt(info, a3))), toList(a4));

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 7.

    yyResult = p$$Shared31(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if (':' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pw(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if ('=' == yyC) {
              yyIndex = yyResult.index + 1;

              yyResult = pw(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                final int yyChoice1 = yyResult.index;

                // Nested alternative 1.

                yyResult = pAssemblyExpression(yyChoice1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  AssemblyExpression a2 = yyResult.semanticValue();

                  Span span = createSpan(yyStart,yyCount);
                  yyValue = new AssemblyAssignX(NodeUtil.makeASTNodeInfo(span), a1, a2);

                  return yyResult.createValue(yyValue, yyError);
                }

                // Nested alternative 2.

                yyResult = pFunctionalAssemblyExpression(yyChoice1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  FtnAssembly a2 = yyResult.semanticValue();

                  Span span = createSpan(yyStart,yyCount);
                  yyValue = new AssemblyAssign(NodeUtil.makeASTNodeInfo(span), a1,
                  Some.<FtnAssembly>apply(a2));

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } else {
              yyError = yyError.select("'=' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      }
    }

    // Alternative 8.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (':' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pw(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared31(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Id a1 = yyResult.semanticValue();

            Span span = createSpan(yyStart,yyCount);
            yyValue = new AssemblyAssign(NodeUtil.makeASTNodeInfo(span), a1,
            Option.<FtnAssembly>apply(null));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 9.

    yyResult = p$$Shared31(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          Span span = createSpan(yyStart,yyCount);
          yyValue = new AssemblyLabel(NodeUtil.makeASTNodeInfo(span), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 10.

    yyResult = pNumberLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumberLiteral a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = new AssemblyNumber(NodeUtil.makeASTNodeInfo(span), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 11.

    yyResult = pHexLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumberLiteral a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = new AssemblyNumber(NodeUtil.makeASTNodeInfo(span), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 12.

    yyResult = pStringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StringLiteral a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = new AssemblyString(NodeUtil.makeASTNodeInfo(span), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 13.

    yyResult = pbreak(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      yyValue = new AssemblyBreak(NodeUtil.makeASTNodeInfo(span));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 14.

    yyResult = pcontinue(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      yyValue = new AssemblyContinue(NodeUtil.makeASTNodeInfo(span));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 15.

    yyResult = passembly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared31(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pInlineAssemblyBlock(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<AssemblyItem> a2 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount+1);
              yyValue = new SubAssembly(NodeUtil.makeASTNodeInfo(span), a1, toList(a2));

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 16.

    yyResult = pAssemblyExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 17.

    yyResult = pFunctionalAssemblyExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 18.

    yyResult = p$$Shared31(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = new AssemblyId(NodeUtil.makeASTNodeInfo(span), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("assembly item expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.saf.parser.SOL.AssemblyItem$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssemblyItem$$Star1(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fAssemblyItem$$Star1) 
      yyColumn.chunk3.fAssemblyItem$$Star1 = pAssemblyItem$$Star1$1(yyStart);
    return yyColumn.chunk3.fAssemblyItem$$Star1;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.AssemblyItem$$Star1. */
  private Result pAssemblyItem$$Star1$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    Pair<AssemblyCase> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pAssemblyCase(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        AssemblyCase v$el$2 = yyResult.semanticValue();

        yyResult = pAssemblyItem$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<AssemblyCase> v$3 = yyResult.semanticValue();

          yyValue = new Pair<AssemblyCase>(v$el$2, v$3);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.AssemblyCase.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssemblyCase(final int yyStart) throws IOException {
    Result       yyResult;
    AssemblyCase yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcase(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAssemblyExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          AssemblyExpression a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pInlineAssemblyBlock(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<AssemblyItem> a2 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount+1);
              yyValue = new AssemblyCase(NodeUtil.makeASTNodeInfo(span), a1, toList(a2));

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.AssemblyExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssemblyExpression(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fAssemblyExpression) 
      yyColumn.chunk3.fAssemblyExpression = pAssemblyExpression$1(yyStart);
    return yyColumn.chunk3.fAssemblyExpression;
  }

  /** Actually parse Statement.AssemblyExpression. */
  private Result pAssemblyExpression$1(final int yyStart) throws IOException {
    Result             yyResult;
    AssemblyExpression yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared31(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popenparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            final int yyChoice2 = yyResult.index;

            // Nested alternative 1.

            yyResult = pAssemblyExpressionList(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<AssemblyExpression> a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcloseparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  Span span = createSpan(yyStart,yyCount+1);
                  yyValue = new AssemblyCall(NodeUtil.makeASTNodeInfo(span), a1, toList(a2));

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }

            // Nested alternative 2.

            yyResult = pcloseparen(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              Span span = createSpan(yyStart,yyCount+1);
              yyValue = new AssemblyCall(NodeUtil.makeASTNodeInfo(span), a1, nilAEs);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }

      // Nested alternative 2.

      Span span = createSpan(yyStart,yyCount);
      yyValue = new AssemblyId(NodeUtil.makeASTNodeInfo(span), a1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Alternative 2.

    yyResult = pNumberLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumberLiteral a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = new AssemblyNumber(NodeUtil.makeASTNodeInfo(span), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pHexLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumberLiteral a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = new AssemblyNumber(NodeUtil.makeASTNodeInfo(span), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pStringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StringLiteral a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = new AssemblyString(NodeUtil.makeASTNodeInfo(span), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.AssemblyExpressionList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssemblyExpressionList(final int yyStart) 
    throws IOException {

    Result                   yyResult;
    int                      yyRepetition1;
    Pair<AssemblyExpression> yyRepValue1;
    List<AssemblyExpression> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAssemblyExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AssemblyExpression a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyResult = pAssemblyExpression(yyResult.index);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {
                AssemblyExpression v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = 
                  new Pair<AssemblyExpression>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<AssemblyExpression> a2s = yyRepValue1.reverse();

        yyValue = cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.FunctionalAssemblyExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunctionalAssemblyExpression(final int yyStart) 
    throws IOException {

    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fFunctionalAssemblyExpression) 
      yyColumn.chunk3.fFunctionalAssemblyExpression = pFunctionalAssemblyExpression$1(yyStart);
    return yyColumn.chunk3.fFunctionalAssemblyExpression;
  }

  /** Actually parse Statement.FunctionalAssemblyExpression. */
  private Result pFunctionalAssemblyExpression$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyOption1;
    List<AssemblyItem> yyOpValue1;
    FtnAssembly        yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared31(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popenparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyResult = pAssemblyItemList(yyResult.index);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              List<AssemblyItem> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<AssemblyItem> a2 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                Span span = createSpan(yyStart,yyCount);
                scala.collection.immutable.List<AssemblyItem> ais;
                if (a2 == null) ais = nilAIs;
                else            ais = toList(a2);
                yyValue = new FtnAssembly(NodeUtil.makeASTNodeInfo(span), a1, ais);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a2.
        }
      }

      // Nested alternative 2.

      Span span = createSpan(yyStart,yyCount);
      yyValue = new FtnAssembly(NodeUtil.makeASTNodeInfo(span), a1, nilAIs);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.AssemblyItemList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssemblyItemList(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<AssemblyItem> yyRepValue1;
    List<AssemblyItem> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAssemblyItem(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AssemblyItem a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyResult = pAssemblyItem(yyResult.index);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {
                AssemblyItem v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<AssemblyItem>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<AssemblyItem> a2s = yyRepValue1.reverse();

        yyValue = cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Expression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExpression) 
      yyColumn.chunk3.fExpression = pExpression$1(yyStart);
    return yyColumn.chunk3.fExpression;
  }

  /** Actually parse Expression.Expression. */
  private Result pExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLeftHandSide(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pequals(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expression a3 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              yyValue = new AssignOpApp(NodeUtil.makeASTNodeInfo(span), a1, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyResult = pAssignmentOp(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expression a3 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              yyValue = new AssignOpApp(NodeUtil.makeASTNodeInfo(span), a1, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pConditional(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Conditional.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConditional(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLogicalOR(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pquestion(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expression a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcolon(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pExpression(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Expression a3 = yyResult.semanticValue();

                      Span span = createSpan(yyStart,yyCount);
                      yyValue = new Cond(NodeUtil.makeASTNodeInfo(span), a1, a2, a3);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pLogicalOR(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.LogicalOR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalOR(final int yyStart) throws IOException {
    Result                      yyResult;
    int                         yyRepetition1;
    Pair<Tuple2<Op,Expression>> yyRepValue1;
    Expression                  yyValue;
    ParseError                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLogicalAND(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pLogicalANDR(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Tuple2<Op,Expression> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<Tuple2<Op,Expression>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Tuple2<Op,Expression>> a2s = yyRepValue1.reverse();

        Span span = a1.span();
        yyValue = a1;
        for (Tuple2<Op, Expression> pair: a2s.list()) {
          Op op = pair._1();
          Expression right = pair._2();
          yyValue = new InfixOpApp(NodeUtil.makeASTNodeInfo(Span.merge(span, right.span())),
          yyValue, op, right);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.LogicalANDR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalANDR(final int yyStart) throws IOException {
    Result                yyResult;
    Tuple2<Op,Expression> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pbars(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pLogicalAND(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expression a2 = yyResult.semanticValue();

            yyValue = new Tuple2<Op, Expression>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.LogicalAND.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalAND(final int yyStart) throws IOException {
    Result                      yyResult;
    int                         yyRepetition1;
    Pair<Tuple2<Op,Expression>> yyRepValue1;
    Expression                  yyValue;
    ParseError                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBitwiseOR(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBitwiseORR(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Tuple2<Op,Expression> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<Tuple2<Op,Expression>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Tuple2<Op,Expression>> a2s = yyRepValue1.reverse();

        Span span = a1.span();
        yyValue = a1;
        for (Tuple2<Op, Expression> pair: a2s.list()) {
          Op op = pair._1();
          Expression right = pair._2();
          yyValue = new InfixOpApp(NodeUtil.makeASTNodeInfo(Span.merge(span, right.span())),
          yyValue, op, right);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.BitwiseORR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseORR(final int yyStart) throws IOException {
    Result                yyResult;
    Tuple2<Op,Expression> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pands(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBitwiseOR(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expression a2 = yyResult.semanticValue();

            yyValue = new Tuple2<Op, Expression>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.BitwiseOR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseOR(final int yyStart) throws IOException {
    Result                      yyResult;
    int                         yyRepetition1;
    Pair<Tuple2<Op,Expression>> yyRepValue1;
    Expression                  yyValue;
    ParseError                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBitwiseXOR(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBitwiseXORR(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Tuple2<Op,Expression> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<Tuple2<Op,Expression>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Tuple2<Op,Expression>> a2s = yyRepValue1.reverse();

        Span span = a1.span();
        yyValue = a1;
        for (Tuple2<Op, Expression> pair: a2s.list()) {
          Op op = pair._1();
          Expression right = pair._2();
          yyValue = new InfixOpApp(NodeUtil.makeASTNodeInfo(Span.merge(span, right.span())),
          yyValue, op, right);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.BitwiseXORR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseXORR(final int yyStart) throws IOException {
    Result                yyResult;
    Tuple2<Op,Expression> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pbar(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBitwiseXOR(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expression a2 = yyResult.semanticValue();

            yyValue = new Tuple2<Op, Expression>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.BitwiseXOR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseXOR(final int yyStart) throws IOException {
    Result                      yyResult;
    int                         yyRepetition1;
    Pair<Tuple2<Op,Expression>> yyRepValue1;
    Expression                  yyValue;
    ParseError                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBitwiseAND(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBitwiseANDR(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Tuple2<Op,Expression> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<Tuple2<Op,Expression>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Tuple2<Op,Expression>> a2s = yyRepValue1.reverse();

        Span span = a1.span();
        yyValue = a1;
        for (Tuple2<Op, Expression> pair: a2s.list()) {
          Op op = pair._1();
          Expression right = pair._2();
          yyValue = new InfixOpApp(NodeUtil.makeASTNodeInfo(Span.merge(span, right.span())),
          yyValue, op, right);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.BitwiseANDR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseANDR(final int yyStart) throws IOException {
    Result                yyResult;
    Tuple2<Op,Expression> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcaret(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBitwiseAND(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expression a2 = yyResult.semanticValue();

            yyValue = new Tuple2<Op, Expression>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.BitwiseAND.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseAND(final int yyStart) throws IOException {
    Result                      yyResult;
    int                         yyRepetition1;
    Pair<Tuple2<Op,Expression>> yyRepValue1;
    Expression                  yyValue;
    ParseError                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEquality(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pEqualityR(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Tuple2<Op,Expression> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<Tuple2<Op,Expression>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Tuple2<Op,Expression>> a2s = yyRepValue1.reverse();

        Span span = a1.span();
        yyValue = a1;
        for (Tuple2<Op, Expression> pair: a2s.list()) {
          Op op = pair._1();
          Expression right = pair._2();
          yyValue = new InfixOpApp(NodeUtil.makeASTNodeInfo(Span.merge(span, right.span())),
          yyValue, op, right);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.EqualityR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityR(final int yyStart) throws IOException {
    Result                yyResult;
    Tuple2<Op,Expression> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pand(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pEquality(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expression a2 = yyResult.semanticValue();

            yyValue = new Tuple2<Op, Expression>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Equality.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEquality(final int yyStart) throws IOException {
    Result                      yyResult;
    int                         yyRepetition1;
    Pair<Tuple2<Op,Expression>> yyRepValue1;
    Expression                  yyValue;
    ParseError                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRelational(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pRelationalR(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Tuple2<Op,Expression> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<Tuple2<Op,Expression>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Tuple2<Op,Expression>> a2s = yyRepValue1.reverse();

        Span span = a1.span();
        yyValue = a1;
        for (Tuple2<Op, Expression> pair: a2s.list()) {
          Op op = pair._1();
          Expression right = pair._2();
          yyValue = new InfixOpApp(NodeUtil.makeASTNodeInfo(Span.merge(span, right.span())),
          yyValue, op, right);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.RelationalR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalR(final int yyStart) throws IOException {
    Result                yyResult;
    Tuple2<Op,Expression> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pEqualityOp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pRelational(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expression a2 = yyResult.semanticValue();

            yyValue = new Tuple2<Op, Expression>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Relational.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelational(final int yyStart) throws IOException {
    Result                      yyResult;
    int                         yyRepetition1;
    boolean                     yyRepeated1;
    Pair<Tuple2<Expression,Op>> yyRepValue1;
    Expression                  yyValue;
    ParseError                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pShiftL(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Tuple2<Expression,Op> v$el$2 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Tuple2<Expression,Op>>(v$el$2, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Tuple2<Expression,Op>> a1s = yyRepValue1.reverse();

      yyResult = pShift(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expression a2 = yyResult.semanticValue();

        List<Tuple2<Expression, Op>> ps = a1s.list();
        Tuple2<Expression, Op> first = ps.remove(0);
        Expression left = first._1();
        Op op = first._2();
        Span span = left.span();
        for (Tuple2<Expression, Op> pair: ps) {
          Expression e = pair._1();
          left = new InfixOpApp(NodeUtil.makeASTNodeInfo(Span.merge(span, e.span())),
          left, op, e);
          op = pair._2();
        }
        yyValue = new InfixOpApp(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)), left, op, a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pShift(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.ShiftL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pShiftL(final int yyStart) throws IOException {
    Result                yyResult;
    Tuple2<Expression,Op> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pShift(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pRelationalOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new Tuple2<Expression, Op>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Shift.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pShift(final int yyStart) throws IOException {
    Result                      yyResult;
    int                         yyRepetition1;
    boolean                     yyRepeated1;
    Pair<Tuple2<Expression,Op>> yyRepValue1;
    Expression                  yyValue;
    ParseError                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pAdditiveL(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Tuple2<Expression,Op> v$el$2 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Tuple2<Expression,Op>>(v$el$2, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Tuple2<Expression,Op>> a1s = yyRepValue1.reverse();

      yyResult = pAdditive(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expression a2 = yyResult.semanticValue();

        List<Tuple2<Expression, Op>> ps = a1s.list();
        Tuple2<Expression, Op> first = ps.remove(0);
        Expression left = first._1();
        Op op = first._2();
        Span span = left.span();
        for (Tuple2<Expression, Op> pair: ps) {
          Expression e = pair._1();
          left = new InfixOpApp(NodeUtil.makeASTNodeInfo(Span.merge(span, e.span())),
          left, op, e);
          op = pair._2();
        }
        yyValue = new InfixOpApp(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)), left, op, a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pAdditive(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.AdditiveL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditiveL(final int yyStart) throws IOException {
    Result                yyResult;
    Tuple2<Expression,Op> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAdditive(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pShiftOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new Tuple2<Expression, Op>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Additive.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditive(final int yyStart) throws IOException {
    Result                      yyResult;
    int                         yyRepetition1;
    boolean                     yyRepeated1;
    Pair<Tuple2<Expression,Op>> yyRepValue1;
    Expression                  yyValue;
    ParseError                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pMultiplicativeL(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Tuple2<Expression,Op> v$el$2 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Tuple2<Expression,Op>>(v$el$2, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Tuple2<Expression,Op>> a1s = yyRepValue1.reverse();

      yyResult = pMultiplicative(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expression a2 = yyResult.semanticValue();

        List<Tuple2<Expression, Op>> ps = a1s.list();
        Tuple2<Expression, Op> first = ps.remove(0);
        Expression left = first._1();
        Op op = first._2();
        Span span = left.span();
        for (Tuple2<Expression, Op> pair: ps) {
          Expression e = pair._1();
          left = new InfixOpApp(NodeUtil.makeASTNodeInfo(Span.merge(span, e.span())),
          left, op, e);
          op = pair._2();
        }
        yyValue = new InfixOpApp(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)), left, op, a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pMultiplicative(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.MultiplicativeL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicativeL(final int yyStart) throws IOException {
    Result                yyResult;
    Tuple2<Expression,Op> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMultiplicative(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAdditiveOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new Tuple2<Expression, Op>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Multiplicative.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicative(final int yyStart) throws IOException {
    Result                      yyResult;
    int                         yyRepetition1;
    boolean                     yyRepeated1;
    Pair<Tuple2<Expression,Op>> yyRepValue1;
    Expression                  yyValue;
    ParseError                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pUnaryL(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Tuple2<Expression,Op> v$el$2 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Tuple2<Expression,Op>>(v$el$2, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Tuple2<Expression,Op>> a1s = yyRepValue1.reverse();

      yyResult = pUnary(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expression a2 = yyResult.semanticValue();

        List<Tuple2<Expression, Op>> ps = a1s.list();
        Tuple2<Expression, Op> first = ps.remove(0);
        Expression left = first._1();
        Op op = first._2();
        Span span = left.span();
        for (Tuple2<Expression, Op> pair: ps) {
          Expression e = pair._1();
          left = new InfixOpApp(NodeUtil.makeASTNodeInfo(Span.merge(span, e.span())),
          left, op, e);
          op = pair._2();
        }
        yyValue = new InfixOpApp(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)), left, op, a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pUnary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.UnaryL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnaryL(final int yyStart) throws IOException {
    Result                yyResult;
    Tuple2<Expression,Op> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUnary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pMultiplicativeOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new Tuple2<Expression, Op>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Unary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnary(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbang(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = new PrefixOpApp(NodeUtil.makeASTNodeInfo(span), a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = ptilde(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = new PrefixOpApp(NodeUtil.makeASTNodeInfo(span), a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = pdelete(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = new PrefixOpApp(NodeUtil.makeASTNodeInfo(span), a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyResult = pdoubleplus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = new PrefixOpApp(NodeUtil.makeASTNodeInfo(span), a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyResult = pdoubleminus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = new PrefixOpApp(NodeUtil.makeASTNodeInfo(span), a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 6.

    yyResult = pplus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = new PrefixOpApp(NodeUtil.makeASTNodeInfo(span), a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 7.

    yyResult = pminus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = new PrefixOpApp(NodeUtil.makeASTNodeInfo(span), a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 8.

    yyResult = pPostfix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Postfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostfix(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLeftHandSide(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyResult = ps(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pdoubleplus(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = new UnaryAssignOpApp(NodeUtil.makeASTNodeInfo(span), a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pdoubleminus(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = new UnaryAssignOpApp(NodeUtil.makeASTNodeInfo(span), a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pLeftHandSide(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.LeftHandSide.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLeftHandSide(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fLeftHandSide) 
      yyColumn.chunk4.fLeftHandSide = pLeftHandSide$1(yyStart);
    return yyColumn.chunk4.fLeftHandSide;
  }

  /** Actually parse Expression.LeftHandSide. */
  private Result pLeftHandSide$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCallExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNewExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.CallExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCallExpression(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fCallExpression) 
      yyColumn.chunk4.fCallExpression = pCallExpression$1(yyStart);
    return yyColumn.chunk4.fCallExpression;
  }

  /** Actually parse Expression.CallExpression. */
  private Result pCallExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCallExpressionFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression seed = yyResult.semanticValue();

      yyResult = pCallExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expression>> list = yyResult.semanticValue();

        yyValue = (Expression)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.saf.parser.SOL.CallExpression$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCallExpression$$Star1(final int yyStart) 
    throws IOException {

    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fCallExpression$$Star1) 
      yyColumn.chunk4.fCallExpression$$Star1 = pCallExpression$$Star1$1(yyStart);
    return yyColumn.chunk4.fCallExpression$$Star1;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.CallExpression$$Star1. */
  private Result pCallExpression$$Star1$1(final int yyStart) 
    throws IOException {

    Result                   yyResult;
    Pair<Action<Expression>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCallExpressionTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Expression> v$el$1 = yyResult.semanticValue();

      yyResult = pCallExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expression>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expression>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.CallExpressionFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCallExpressionFront(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMemberExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pArgs(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Expression> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount+1);
          yyValue = new FunctionCall(NodeUtil.makeASTNodeInfo(span), a1, toList(a2));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.CallExpressionTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCallExpressionTail(final int yyStart) throws IOException {
    Result             yyResult;
    Action<Expression> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pArgs(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<Expression> a1 = yyResult.semanticValue();

        yyValue = new Action<Expression>() {
          public Expression run(Expression base) {
            SourceLoc loc = base.span().begin();
            Span last;
            if (a1.isEmpty()) last = base.span();
            else last = a1.get(a1.size()-1).span();
            Span span = new Span(base.span().fileName(),
            loc.line(), last.end().line(),
            loc.column(), last.end().column()+1,
            base.info().span().begin().offset(),
            last.end().offset()+1);
            return new FunctionCall(NodeUtil.makeASTNodeInfo(span), (Expression)base, toList(a1));
        }};

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = popensquare(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          final int yyChoice2 = yyResult.index;

          // Nested alternative 1.

          yyResult = pExpression(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Expression a1 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosesquare(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = new Action<Expression>() {
                  public Expression run(Expression base) {
                    SourceLoc loc = base.span().begin();
                    Span span = new Span(base.span().fileName(),
                    loc.line(), a1.info().span().end().line(),
                    loc.column()+1, a1.span().end().column()+1,
                    base.info().span().begin().offset(),
                    a1.info().span().end().offset()+1);
                    return new Bracket(NodeUtil.makeASTNodeInfo(span), (Expression)base,
                    Some.<Expression>apply(a1));
                }};

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 2.

          yyResult = pclosesquare(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new Action<Expression>() {
              public Expression run(Expression base) {
                Span span = base.span();
                return new Bracket(NodeUtil.makeASTNodeInfo(span), (Expression)base,
                Option.<Expression>apply(null));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 3.

      yyResult = pdot(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared31(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Id a1 = yyResult.semanticValue();

            yyValue = new Action<Expression>() {
              public Expression run(Expression base) {
                return new Dot(NodeUtil.makeASTNodeInfo(Span.merge(base.span(),
                a1.span())),
                (Expression)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Args.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgs(final int yyStart) throws IOException {
    Result           yyResult;
    List<Expression> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pcloseparen(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = list();

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pArgList(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.ArgList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgList(final int yyStart) throws IOException {
    Result           yyResult;
    int              yyRepetition1;
    Pair<Expression> yyRepValue1;
    int              yyOption1;
    List<Expression> yyOpValue1;
    List<Expression> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyResult = pExpression(yyResult.index);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {
                Expression v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Expression>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Expression> a2s = yyRepValue1.reverse();

        yyValue = cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyResult = pNameValueList(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          List<Expression> v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a1.
        List<Expression> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pclosecurly(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            List<Expression> args;
            if (a1 == null) args = Collections.<Expression>emptyList();
            else args = a1;
            yyValue = args;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.NameValueList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNameValueList(final int yyStart) throws IOException {
    Result           yyResult;
    int              yyRepetition1;
    Pair<Expression> yyRepValue1;
    int              yyOption1;
    List<Expression> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNameValuePair(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyResult = pNameValuePair(yyResult.index);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {
                Expression v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Expression>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Expression> a2s = yyRepValue1.reverse();

        yyOption1  = yyRepetition1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }
        }

        yyValue = cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.NameValuePair.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNameValuePair(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared31(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expression a1 = yyResult.semanticValue();

              yyValue = a1;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.NewExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNewExpression(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMemberExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pnew(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pCallExpression(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression a1 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = new NewCall(NodeUtil.makeASTNodeInfo(span), a1);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pTypeName(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          TypeName a1 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = new New(NodeUtil.makeASTNodeInfo(span), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.MemberExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMemberExpression(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fMemberExpression) 
      yyColumn.chunk4.fMemberExpression = pMemberExpression$1(yyStart);
    return yyColumn.chunk4.fMemberExpression;
  }

  /** Actually parse Expression.MemberExpression. */
  private Result pMemberExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPrimaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression seed = yyResult.semanticValue();

      yyResult = pMemberExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expression>> list = yyResult.semanticValue();

        yyValue = (Expression)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.saf.parser.SOL.MemberExpression$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMemberExpression$$Star1(final int yyStart) 
    throws IOException {

    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fMemberExpression$$Star1) 
      yyColumn.chunk4.fMemberExpression$$Star1 = pMemberExpression$$Star1$1(yyStart);
    return yyColumn.chunk4.fMemberExpression$$Star1;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.MemberExpression$$Star1. */
  private Result pMemberExpression$$Star1$1(final int yyStart) 
    throws IOException {

    Result                   yyResult;
    Pair<Action<Expression>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMemberExpressionTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Expression> v$el$1 = yyResult.semanticValue();

      yyResult = pMemberExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expression>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expression>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.MemberExpressionTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMemberExpressionTail(final int yyStart) throws IOException {
    Result             yyResult;
    Action<Expression> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = popensquare(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          final int yyChoice2 = yyResult.index;

          // Nested alternative 1.

          yyResult = pExpression(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Expression a1 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosesquare(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = new Action<Expression>() {
                  public Expression run(Expression base) {
                    SourceLoc loc = base.span().begin();
                    Span span = new Span(base.span().fileName(), loc.line(),
                    a1.info().span().end().line(),
                    loc.column()+1, a1.span().end().column()+1,
                    base.info().span().begin().offset(), a1.info().span().end().offset()+1);
                    return new Bracket(NodeUtil.makeASTNodeInfo(span), (Expression)base,
                    Some.<Expression>apply(a1));
                }};

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 2.

          yyResult = pclosesquare(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new Action<Expression>() {
              public Expression run(Expression base) {
                Span span = base.span();
                return new Bracket(NodeUtil.makeASTNodeInfo(span), (Expression)base,
                Option.<Expression>apply(null));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyResult = pdot(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared31(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Id a1 = yyResult.semanticValue();

            yyValue = new Action<Expression>() {
              public Expression run(Expression base) {
                return new Dot(NodeUtil.makeASTNodeInfo(Span.merge(base.span(),
                a1.span())),
                (Expression)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.PrimaryExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrimaryExpression(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pElementaryTypeName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      ASTNodeInfo info = NodeUtil.makeASTNodeInfo(span);
      yyValue = new TypeRef(info, new ElementaryTypeName(info, a1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pCollectionLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 5.

    yyResult = p$$Shared31(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = new VarRef(NodeUtil.makeASTNodeInfo(span), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.CollectionLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCollectionLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pElementList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Expression> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosesquare(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              Span span = createSpan(yyStart,yyCount+1);
              if (writer != null) { writer.close(); initParser(); }
              yyValue = new ArrayLiteral(NodeUtil.makeASTNodeInfo(span),
              toList(a1));

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pElementList(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Expression> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              Span span = createSpan(yyStart,yyCount+1);
              if (writer != null) { writer.close(); initParser(); }
              yyValue = new TupleLiteral(NodeUtil.makeASTNodeInfo(span),
              toList(a1));

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyResult = pOptElementList(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Option<Expression>> a1 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount+1);
          if (writer != null) { writer.close(); initParser(); }
          yyValue = new TupleOptLiteral(NodeUtil.makeASTNodeInfo(span),
          toList(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.ElementList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElementList(final int yyStart) throws IOException {
    Result                         yyResult;
    int                            yyRepetition1;
    Pair<Action<List<Expression>>> yyRepValue1;
    List<Expression>               yyValue;
    ParseError                     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pElementListHead(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Expression> seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pElementListTail(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Action<List<Expression>> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<Action<List<Expression>>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for list.
        Pair<Action<List<Expression>>> list = yyRepValue1.reverse();

        yyValue = (List<Expression>)apply(list, seed);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for list.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.ElementListHead.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElementListHead(final int yyStart) throws IOException {
    Result           yyResult;
    List<Expression> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      List<Expression> result = new ArrayList<Expression>();
      yyValue = cons(a1, result);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.ElementListTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElementListTail(final int yyStart) throws IOException {
    Result                   yyResult;
    Action<List<Expression>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Expression a1 = yyResult.semanticValue();

            yyValue = new Action<List<Expression>>() {
              public List<Expression> run(List<Expression> base) {
                List<Expression> result = new ArrayList<Expression>();
                result.addAll(base);
                return list(result, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.OptElementList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOptElementList(final int yyStart) throws IOException {
    Result                   yyResult;
    List<Option<Expression>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pOptElementList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Option<Expression>> a2 = yyResult.semanticValue();

              yyValue = cons(Some.<Expression>apply(a1), a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pOptElementList(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Option<Expression>> a1 = yyResult.semanticValue();

            yyValue = cons(Option.<Expression>apply(null), a1);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 3.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcloseparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = list(Some.<Expression>apply(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyResult = pcloseparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Collections.<Option<Expression>>emptyList();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.Literal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Literal    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ptrue(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      yyValue = new Bool(NodeUtil.makeASTNodeInfo(span), true);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pfalse(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      yyValue = new Bool(NodeUtil.makeASTNodeInfo(span), false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pNumberLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pHexLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pStringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.NumberLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumberLiteral(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fNumberLiteral) 
      yyColumn.chunk4.fNumberLiteral = pNumberLiteral$1(yyStart);
    return yyColumn.chunk4.fNumberLiteral;
  }

  /** Actually parse Literal.NumberLiteral. */
  private Result pNumberLiteral$1(final int yyStart) throws IOException {
    Result        yyResult;
    Result        yyPredResult;
    boolean       yyPredMatched;
    int           yyOption1;
    NumberLiteral yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pHexNumber(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyPredMatched = false;

      yyPredResult = pidrest(yyResult.index);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyOption1  = yyResult.index;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyResult = pNumberUnit(yyResult.index);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }
        }

        return new SemanticValue(yyValue, yyOption1, yyError);
      } else {
        yyError = yyError.select("number literal expected", yyStart);
      }
    }

    // Alternative 2.

    yyResult = pDecimalNumber(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyPredMatched = false;

      yyPredResult = pidrest(yyResult.index);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyOption1  = yyResult.index;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyResult = pNumberUnit(yyResult.index);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }
        }

        return new SemanticValue(yyValue, yyOption1, yyError);
      } else {
        yyError = yyError.select("number literal expected", yyStart);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.HexNumber.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexNumber(final int yyStart) throws IOException {
    int           yyC;
    int           yyIndex;
    Result        yyResult;
    int           yyBase;
    NumberLiteral yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pHexNumber$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pHexDigits(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a1 = yyResult.semanticValue();

        Span span = createSpan(yyStart,yyCount);
        yyValue = new IntLiteral(NodeUtil.makeASTNodeInfo(span), new BigInteger(a1, 16), 16);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('h' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('x' == yyC) {
          yyIndex = yyIndex + 1;

          yyResult = pw(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyC = character(yyChoice1);
            if (-1 != yyC) {
              yyIndex = yyChoice1 + 1;

              switch (yyC) {
              case '\'':
                {
                  final int yyChoice2 = yyIndex;

                  // Nested alternative 1.

                  yyResult = pw(yyChoice2);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyBase = yyResult.index;
                    yyC    = character(yyBase);
                    if ('\'' == yyC) {
                      yyIndex = yyResult.index + 1;

                      Span span = createSpan(yyStart,yyCount);
                      yyValue = new IntLiteral(NodeUtil.makeASTNodeInfo(span), new BigInteger("0", 16), 16);

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("'\\\'' expected", yyBase);
                    }
                  }

                  // Nested alternative 2.

                  yyResult = pHexDigits(yyChoice2);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    String a1 = yyResult.semanticValue();

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyBase = yyResult.index;
                      yyC    = character(yyBase);
                      if ('\'' == yyC) {
                        yyIndex = yyResult.index + 1;

                        Span span = createSpan(yyStart,yyCount);
                        yyValue = new IntLiteral(NodeUtil.makeASTNodeInfo(span), new BigInteger(a1, 16), 16);

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("'\\\'' expected", yyBase);
                      }
                    }
                  }
                }
                break;

              case '\"':
                {
                  final int yyChoice2 = yyIndex;

                  // Nested alternative 1.

                  yyResult = pw(yyChoice2);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyBase = yyResult.index;
                    yyC    = character(yyBase);
                    if ('\"' == yyC) {
                      yyIndex = yyResult.index + 1;

                      Span span = createSpan(yyStart,yyCount);
                      yyValue = new IntLiteral(NodeUtil.makeASTNodeInfo(span), new BigInteger("0", 16), 16);

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("'\\\"' expected", yyBase);
                    }
                  }

                  // Nested alternative 2.

                  yyResult = pHexDigits(yyChoice2);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    String a1 = yyResult.semanticValue();

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyC = character(yyResult.index);
                      if ('\"' == yyC) {
                        yyIndex = yyResult.index + 1;

                        Span span = createSpan(yyStart,yyCount);
                        yyValue = new IntLiteral(NodeUtil.makeASTNodeInfo(span), new BigInteger(a1, 16), 16);

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }
                    }
                  }
                }
                break;

              default:
                /* No match. */
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("hex number expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.saf.parser.SOL.HexNumber$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexNumber$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('0' == yyC) {

        yyC = character(yyIndex);
        if (-1 != yyC) {
          yyIndex = yyIndex + 1;

          switch (yyC) {
          case 'x':
            {
              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }

          case 'X':
            {
              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }

          default:
            /* No match. */
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("hex number expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.HexDigit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral$HexDigit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("hex digit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.HexDigits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("hex digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.HexDigit2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexDigit2(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLiteral$HexDigit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pLiteral$HexDigit(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyValue = a1+a2;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.NumberUnit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumberUnit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'd':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('y' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('s' == yyC) {

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("number unit expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'e':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('t' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('h' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('r' == yyC) {

                          yyPredMatched = false;

                          yyPredResult = pidrest(yyIndex);
                          if (yyPredResult.hasValue()) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyValue = null;

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          } else {
                            yyError = yyError.select("number unit expected", yyStart);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'f':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('i' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('n' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('n' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('e' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('y' == yyC) {

                              yyPredMatched = false;

                              yyPredResult = pidrest(yyIndex);
                              if (yyPredResult.hasValue()) {

                                yyPredMatched = true;
                              }

                              if (! yyPredMatched) {

                                yyValue = null;

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              } else {
                                yyError = yyError.select("number unit expected", yyStart);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'h':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('o' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('u' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('r' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('s' == yyC) {

                          yyPredMatched = false;

                          yyPredResult = pidrest(yyIndex);
                          if (yyPredResult.hasValue()) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyValue = null;

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          } else {
                            yyError = yyError.select("number unit expected", yyStart);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'm':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('i' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('n' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('u' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('t' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('e' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('s' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = null;

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("number unit expected", yyStart);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 's':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'e':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('c' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('o' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('n' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('d' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('s' == yyC) {

                                    yyPredMatched = false;

                                    yyPredResult = pidrest(yyIndex);
                                    if (yyPredResult.hasValue()) {

                                      yyPredMatched = true;
                                    }

                                    if (! yyPredMatched) {

                                      yyValue = null;

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("number unit expected", yyStart);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'z':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('a' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('b' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('o' == yyC) {

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyIndex);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = null;

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("number unit expected", yyStart);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'w':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('e' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;

                switch (yyC) {
                case 'e':
                  {
                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('k' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('s' == yyC) {

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyIndex);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = null;

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("number unit expected", yyStart);
                            }
                          }
                        }
                      }
                    }
                  }
                  break;

                case 'i':
                  {
                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("number unit expected", yyStart);
                    }
                  }
                  break;

                default:
                  /* No match. */
                }
              }
            }
          }
        }
        break;

      case 'y':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('e' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('a' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('r' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('s' == yyC) {

                          yyPredMatched = false;

                          yyPredResult = pidrest(yyIndex);
                          if (yyPredResult.hasValue()) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyValue = null;

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          } else {
                            yyError = yyError.select("number unit expected", yyStart);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("number unit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.DecimalNumber.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalNumber(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyOption1;
    String        yyOpValue1;
    NumberLiteral yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDecimalDigits(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pdot(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyResult = pDecimalDigits(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        String a2 = yyOpValue1;

        yyOpValue1 = null;

        yyResult = pExponentPart(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          String v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for a3.
          String a3 = yyOpValue1;

          if (Character.isDigit(a1.charAt(0)) || a1.charAt(0) == '.') {

            Span span = createSpan(yyStart,yyCount);
            String dot = "";
            if (a2 == null) a2 = ""; else dot = ".";
            if (a3 == null) a3 = "";
            yyValue = makeNumberLiteral(writer, span, a1, dot, a2, a3);

            return new SemanticValue(yyValue, yyOption1, yyError);
          }
        } // End scope for a3.
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pdot(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pDecimalDigits(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        String v$el$3 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$3;
      }
      { // Start scope for a1.
        String a1 = yyOpValue1;

        yyOpValue1 = null;

        yyResult = pExponentPart(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          String v$el$4 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$4;
        }
        { // Start scope for a2.
          String a2 = yyOpValue1;

          if ((a1 != null) && (Character.isDigit(a1.charAt(0)) || a1.charAt(0) == '.')) {

            Span span = createSpan(yyStart,yyCount);
            if (a1 == null) a1 = "";
            if (a2 == null) a2 = "";
            yyValue = makeNumberLiteral(writer, span, "", ".", a1, a2);

            return new SemanticValue(yyValue, yyOption1, yyError);
          }
        } // End scope for a2.
      } // End scope for a1.
    }

    // Done.
    yyError = yyError.select("decimal number expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.DecimalDigits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("decimal digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.ExponentPart.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExponentPart(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'E':
      case 'e':
        {
          yyResult = pDecimalDigits(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a1 = yyResult.semanticValue();

            yyValue = "e"+a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("exponent part expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.HexLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexLiteral(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fHexLiteral) 
      yyColumn.chunk4.fHexLiteral = pHexLiteral$1(yyStart);
    return yyColumn.chunk4.fHexLiteral;
  }

  /** Actually parse Literal.HexLiteral. */
  private Result pHexLiteral$1(final int yyStart) throws IOException {
    int           yyC;
    int           yyIndex;
    Result        yyResult;
    NumberLiteral yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('h' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('x' == yyC) {
          yyIndex = yyIndex + 1;

          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '\"':
              {
                yyResult = pHexLiteral$$Plus1(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Pair<String> a1s = yyResult.semanticValue();

                  yyC = character(yyResult.index);
                  if ('\"' == yyC) {
                    yyIndex = yyResult.index + 1;

                    Span span = createSpan(yyStart,yyCount);
                    String digits = "";
                    for (String c : (List<String>)a1s.list()) digits = digits.concat(c);
                    yyValue = new IntLiteral(NodeUtil.makeASTNodeInfo(span), new BigInteger(digits, 16), 16);

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case '\'':
              {
                yyResult = pHexLiteral$$Plus2(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Pair<String> a1s = yyResult.semanticValue();

                  yyC = character(yyResult.index);
                  if ('\'' == yyC) {
                    yyIndex = yyResult.index + 1;

                    Span span = createSpan(yyStart,yyCount);
                    String digits = "";
                    for (String c : (List<String>)a1s.list()) digits = digits.concat(c);
                    yyValue = new IntLiteral(NodeUtil.makeASTNodeInfo(span), new BigInteger(digits, 16), 16);

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("hex literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.HexLiteral$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexLiteral$$Plus1(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fHexLiteral$$Plus1) 
      yyColumn.chunk4.fHexLiteral$$Plus1 = pHexLiteral$$Plus1$1(yyStart);
    return yyColumn.chunk4.fHexLiteral$$Plus1;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.HexLiteral$$Plus1. */
  private Result pHexLiteral$$Plus1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pHexDigit2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pHexLiteral$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> v$2 = yyResult.semanticValue();

        yyValue = new Pair<String>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<String>(v$el$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.HexLiteral$$Plus2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexLiteral$$Plus2(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fHexLiteral$$Plus2) 
      yyColumn.chunk4.fHexLiteral$$Plus2 = pHexLiteral$$Plus2$1(yyStart);
    return yyColumn.chunk4.fHexLiteral$$Plus2;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.HexLiteral$$Plus2. */
  private Result pHexLiteral$$Plus2$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pHexDigit2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$3 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pHexLiteral$$Plus2(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> v$4 = yyResult.semanticValue();

        yyValue = new Pair<String>(v$el$3, v$4);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<String>(v$el$3);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.StringLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteral(final int yyStart) throws IOException {
    int           yyC;
    int           yyIndex;
    Result        yyResult;
    int           yyRepetition1;
    Pair<String>  yyRepValue1;
    StringLiteral yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\"':
        {
          yyRepetition1 = yyIndex;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pDoubleStringCharacter(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              String v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for a1s.
            Pair<String> a1s = yyRepValue1.reverse();

            yyC = character(yyRepetition1);
            if ('\"' == yyC) {
              yyIndex = yyRepetition1 + 1;

              String str = "";
              for (String c : (List<String>)a1s.list()) str = str.concat(c);
              yyValue = new StringLiteral(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount+1)), "\"", str);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          } // End scope for a1s.
        }
        break;

      case '\'':
        {
          yyRepetition1 = yyIndex;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pSingleStringCharacter(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              String v$el$2 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<String>(v$el$2, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for a1s.
            Pair<String> a1s = yyRepValue1.reverse();

            yyC = character(yyRepetition1);
            if ('\'' == yyC) {
              yyIndex = yyRepetition1 + 1;

              String str = "";
              for (String c : (List<String>)a1s.list()) str = str.concat(c);
              yyValue = new StringLiteral(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount+1)), "\'", str);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          } // End scope for a1s.
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("string literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.DoubleStringCharacter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDoubleStringCharacter(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      final int yyChoice1 = yyIndex;

      // Nested alternative 1.

      yyResult = pEscapeSequence(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyValue = a2;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = "\\";

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Alternative 2.

    yyResult = pLineContinuation(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDoubleStringCharacter$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = String.valueOf(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("double string character expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.saf.parser.SOL.DoubleStringCharacter$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDoubleStringCharacter$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pNonDoubleStringChar(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        yyValue = Character.valueOf((char)yyC);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("double string character expected", yyStart);
    }

    // Done.
    yyError = yyError.select("double string character expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.EscapeSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEscapeSequence(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if (('\"' == a1) ||
          ('\'' == a1) ||
          ('\\' == a1) ||
          ('n' == a1) ||
          ('r' == a1)) {

        switch (a1) {
          case 'n': { yyValue = "\\n"; break; }
          case 'r': { yyValue = "\\r"; break; }
          case '"': { yyValue = "\\\""; break; }
          case '\'': { yyValue = "\\'"; break; }
          case '\\': { yyValue = "\\\\"; break; }
          default : { yyValue = ""; break; }
        }

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyResult = pEscapeSequence$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = "\\"+a1+"";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if (-1 != yyC) {
        if (('0' <= yyC) && (yyC <= '9')) {

          yyPredMatched = true;
        }
      }

      if (! yyPredMatched) {

        yyValue = "\\0";

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("escape sequence expected", yyStart);
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('x' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      yyResult = pLiteral$HexDigit(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyResult = pLiteral$HexDigit(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a3 = yyResult.semanticValue();

          yyValue = "\\"+a1+a2+a3;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyC = character(yyStart);
    if ('u' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      yyResult = pLiteral$HexDigit(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyResult = pLiteral$HexDigit(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a3 = yyResult.semanticValue();

          yyResult = pLiteral$HexDigit(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a4 = yyResult.semanticValue();

            yyResult = pLiteral$HexDigit(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String a5 = yyResult.semanticValue();

              yyValue = "\\"+a1+a2+a3+a4+a5;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("escape sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.saf.parser.SOL.EscapeSequence$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEscapeSequence$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pEscapeCharOrLT(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        yyValue = Character.valueOf((char)yyC);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("escape sequence expected", yyStart);
    }

    // Done.
    yyError = yyError.select("escape sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.EscapeCharOrLT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEscapeCharOrLT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if ((('0' <= a1) && (a1 <= '9')) ||
          ('u' == a1) ||
          ('x' == a1)) {

        yyValue = a1+"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyResult = p$$Shared15(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("escape char or l t expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.LineContinuation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLineContinuation(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      yyResult = pLineTerminatorSequence(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyValue = a1+a2;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("line continuation expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.NonDoubleStringChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonDoubleStringChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if (('\"' == a1) ||
          ('\\' == a1)) {

        yyValue = a1+"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyResult = p$$Shared15(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("non double string char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.SingleStringCharacter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSingleStringCharacter(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      yyResult = pEscapeSequence(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyValue = a2;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pLineContinuation(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pSingleStringCharacter$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = a1+"";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("single string character expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.saf.parser.SOL.SingleStringCharacter$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSingleStringCharacter$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pNonSingleStringChar(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        yyValue = Character.valueOf((char)yyC);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("single string character expected", yyStart);
    }

    // Done.
    yyError = yyError.select("single string character expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.NonSingleStringChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonSingleStringChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if (('\'' == a1) ||
          ('\\' == a1)) {

        yyValue = a1+"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyResult = p$$Shared15(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("non single string char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.TypeName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeName(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fTypeName) 
      yyColumn.chunk4.fTypeName = pTypeName$1(yyStart);
    return yyColumn.chunk4.fTypeName;
  }

  /** Actually parse Literal.TypeName. */
  private Result pTypeName$1(final int yyStart) throws IOException {
    Result     yyResult;
    TypeName   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypeNameFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeName seed = yyResult.semanticValue();

      yyResult = pTypeName$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<TypeName>> list = yyResult.semanticValue();

        yyValue = (TypeName)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.TypeName$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeName$$Star1(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fTypeName$$Star1) 
      yyColumn.chunk5.fTypeName$$Star1 = pTypeName$$Star1$1(yyStart);
    return yyColumn.chunk5.fTypeName$$Star1;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.TypeName$$Star1. */
  private Result pTypeName$$Star1$1(final int yyStart) throws IOException {
    Result                 yyResult;
    Pair<Action<TypeName>> yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypeNameTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<TypeName> v$el$1 = yyResult.semanticValue();

      yyResult = pTypeName$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<TypeName>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<TypeName>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.TypeNameFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeNameFront(final int yyStart) throws IOException {
    Result     yyResult;
    TypeName   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pElementaryTypeName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = new ElementaryTypeName(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount+1)), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pUserDefinedTypeName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pMapping(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pFunctionTypeName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.TypeNameTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeNameTail(final int yyStart) throws IOException {
    Result           yyResult;
    int              yyOption1;
    Action<TypeName> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyResult = pw(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {

      yyResult = ppayable(yyResult.index);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
      }
    }

    yyResult = pArrayType(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.ArrayType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArrayType(final int yyStart) throws IOException {
    Result           yyResult;
    int              yyOption1;
    Expression       yyOpValue1;
    Action<TypeName> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = popensquare(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyResult = pExpression(yyResult.index);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Expression v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        }
        { // Start scope for a1.
          final Expression a1 = yyOpValue1;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosesquare(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {

                yyResult = pArgs(yyResult.index);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                }
              }

              yyValue = new Action<TypeName>() {
                public TypeName run(TypeName base) {
                  SourceLoc loc = base.span().begin();
                  Span last;
                  if (a1 == null) last = base.span();
                  else last = a1.span();
                  Option<Expression> size;
                  if (a1 == null) size = Option.<Expression>apply(null);
                  else size = Some.<Expression>apply(a1);
                  Span span = new Span(base.span().fileName(),
                  loc.line(), last.end().line(),
                  loc.column(), last.end().column()+1,
                  base.info().span().begin().offset(),
                  last.end().offset()+1);
                  return new ArrayTypeName(NodeUtil.makeASTNodeInfo(span),
                  (TypeName)base, size);
              }};

              return new SemanticValue(yyValue, yyOption1, yyError);
            }
          }
        } // End scope for a1.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.ElementaryTypeName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElementaryTypeName(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'a':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('d' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('d' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('r' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('e' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('s' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('s' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "address";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'b':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'o':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('o' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('l' == yyC) {

                        yyPredMatched = false;

                        yyPredResult = pidrest(yyIndex);
                        if (yyPredResult.hasValue()) {

                          yyPredMatched = true;
                        }

                        if (! yyPredMatched) {

                          yyValue = "bool";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        } else {
                          yyError = yyError.select("elementary type name expected", yyStart);
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'y':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('t' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('e' == yyC) {

                        final int yyChoice1 = yyIndex;

                        // Nested alternative 1.

                        yyC = character(yyChoice1);
                        if (-1 != yyC) {
                          yyIndex = yyChoice1 + 1;
                          if ('s' == yyC) {

                            final int yyChoice2 = yyIndex;

                            // Nested alternative 1.

                            yyC = character(yyChoice2);
                            if (-1 != yyC) {
                              yyIndex = yyChoice2 + 1;

                              switch (yyC) {
                              case '4':
                                {
                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "bytes4";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                                break;

                              case '5':
                                {
                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "bytes5";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                                break;

                              case '6':
                                {
                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "bytes6";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                                break;

                              case '7':
                                {
                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "bytes7";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                                break;

                              case '8':
                                {
                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "bytes8";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                                break;

                              case '9':
                                {
                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "bytes9";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                                break;

                              case '1':
                                {
                                  final int yyChoice3 = yyIndex;

                                  // Nested alternative 1.

                                  yyC = character(yyChoice3);
                                  if (-1 != yyC) {
                                    yyIndex = yyChoice3 + 1;

                                    switch (yyC) {
                                    case '0':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes10";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '1':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes11";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '2':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes12";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '3':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes13";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '4':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes14";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '5':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes15";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '6':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes16";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '7':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes17";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '8':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes18";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '9':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes19";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    default:
                                      /* No match. */
                                    }
                                  }

                                  // Nested alternative 2.

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyChoice3);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "bytes1";

                                    return new SemanticValue(yyValue, yyChoice3, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                                break;

                              case '2':
                                {
                                  final int yyChoice3 = yyIndex;

                                  // Nested alternative 1.

                                  yyC = character(yyChoice3);
                                  if (-1 != yyC) {
                                    yyIndex = yyChoice3 + 1;

                                    switch (yyC) {
                                    case '0':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes20";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '1':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes21";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '2':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes22";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '3':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes23";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '4':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes24";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '5':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes25";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '6':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes26";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '7':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes27";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '8':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes28";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '9':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes29";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    default:
                                      /* No match. */
                                    }
                                  }

                                  // Nested alternative 2.

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyChoice3);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "bytes2";

                                    return new SemanticValue(yyValue, yyChoice3, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                                break;

                              case '3':
                                {
                                  final int yyChoice3 = yyIndex;

                                  // Nested alternative 1.

                                  yyC = character(yyChoice3);
                                  if (-1 != yyC) {
                                    yyIndex = yyChoice3 + 1;

                                    switch (yyC) {
                                    case '0':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes30";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '1':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes31";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '2':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "bytes32";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    default:
                                      /* No match. */
                                    }
                                  }

                                  // Nested alternative 2.

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyChoice3);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "bytes3";

                                    return new SemanticValue(yyValue, yyChoice3, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                                break;

                              default:
                                /* No match. */
                              }
                            }

                            // Nested alternative 2.

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyChoice2);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = "bytes";

                              return new SemanticValue(yyValue, yyChoice2, yyError);
                            } else {
                              yyError = yyError.select("elementary type name expected", yyStart);
                            }
                          }
                        }

                        // Nested alternative 2.

                        yyPredMatched = false;

                        yyPredResult = pidrest(yyChoice1);
                        if (yyPredResult.hasValue()) {

                          yyPredMatched = true;
                        }

                        if (! yyPredMatched) {

                          yyValue = "byte";

                          return new SemanticValue(yyValue, yyChoice1, yyError);
                        } else {
                          yyError = yyError.select("elementary type name expected", yyStart);
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 's':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('t' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('r' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('i' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('n' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('g' == yyC) {

                              yyPredMatched = false;

                              yyPredResult = pidrest(yyIndex);
                              if (yyPredResult.hasValue()) {

                                yyPredMatched = true;
                              }

                              if (! yyPredMatched) {

                                yyValue = "string";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              } else {
                                yyError = yyError.select("elementary type name expected", yyStart);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'v':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('r' == yyC) {

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = "var";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("elementary type name expected", yyStart);
                  }
                }
              }
            }
          }
        }
        break;

      case 'i':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('n' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('t' == yyC) {

                  final int yyChoice1 = yyIndex;

                  // Nested alternative 1.

                  yyC = character(yyChoice1);
                  if (-1 != yyC) {
                    yyIndex = yyChoice1 + 1;

                    switch (yyC) {
                    case '2':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;

                          switch (yyC) {
                          case '0':
                            {
                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;

                                switch (yyC) {
                                case '0':
                                  {
                                    yyPredMatched = false;

                                    yyPredResult = pidrest(yyIndex);
                                    if (yyPredResult.hasValue()) {

                                      yyPredMatched = true;
                                    }

                                    if (! yyPredMatched) {

                                      yyValue = "int200";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("elementary type name expected", yyStart);
                                    }
                                  }
                                  break;

                                case '8':
                                  {
                                    yyPredMatched = false;

                                    yyPredResult = pidrest(yyIndex);
                                    if (yyPredResult.hasValue()) {

                                      yyPredMatched = true;
                                    }

                                    if (! yyPredMatched) {

                                      yyValue = "int208";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("elementary type name expected", yyStart);
                                    }
                                  }
                                  break;

                                default:
                                  /* No match. */
                                }
                              }
                            }
                            break;

                          case '1':
                            {
                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('6' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "int216";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                              }
                            }
                            break;

                          case '2':
                            {
                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('4' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "int224";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                              }
                            }
                            break;

                          case '3':
                            {
                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('2' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "int232";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                              }
                            }
                            break;

                          case '4':
                            {
                              final int yyChoice2 = yyIndex;

                              // Nested alternative 1.

                              yyC = character(yyChoice2);
                              if (-1 != yyC) {
                                yyIndex = yyChoice2 + 1;

                                switch (yyC) {
                                case '0':
                                  {
                                    yyPredMatched = false;

                                    yyPredResult = pidrest(yyIndex);
                                    if (yyPredResult.hasValue()) {

                                      yyPredMatched = true;
                                    }

                                    if (! yyPredMatched) {

                                      yyValue = "int240";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("elementary type name expected", yyStart);
                                    }
                                  }
                                  break;

                                case '8':
                                  {
                                    yyPredMatched = false;

                                    yyPredResult = pidrest(yyIndex);
                                    if (yyPredResult.hasValue()) {

                                      yyPredMatched = true;
                                    }

                                    if (! yyPredMatched) {

                                      yyValue = "int248";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("elementary type name expected", yyStart);
                                    }
                                  }
                                  break;

                                default:
                                  /* No match. */
                                }
                              }

                              // Nested alternative 2.

                              yyPredMatched = false;

                              yyPredResult = pidrest(yyChoice2);
                              if (yyPredResult.hasValue()) {

                                yyPredMatched = true;
                              }

                              if (! yyPredMatched) {

                                yyValue = "int24";

                                return new SemanticValue(yyValue, yyChoice2, yyError);
                              } else {
                                yyError = yyError.select("elementary type name expected", yyStart);
                              }
                            }
                            break;

                          case '5':
                            {
                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('6' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "int256";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                              }
                            }
                            break;

                          default:
                            /* No match. */
                          }
                        }
                      }
                      break;

                    case '3':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('2' == yyC) {

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyIndex);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = "int32";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("elementary type name expected", yyStart);
                            }
                          }
                        }
                      }
                      break;

                    case '4':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;

                          switch (yyC) {
                          case '0':
                            {
                              yyPredMatched = false;

                              yyPredResult = pidrest(yyIndex);
                              if (yyPredResult.hasValue()) {

                                yyPredMatched = true;
                              }

                              if (! yyPredMatched) {

                                yyValue = "int40";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              } else {
                                yyError = yyError.select("elementary type name expected", yyStart);
                              }
                            }
                            break;

                          case '8':
                            {
                              yyPredMatched = false;

                              yyPredResult = pidrest(yyIndex);
                              if (yyPredResult.hasValue()) {

                                yyPredMatched = true;
                              }

                              if (! yyPredMatched) {

                                yyValue = "int48";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              } else {
                                yyError = yyError.select("elementary type name expected", yyStart);
                              }
                            }
                            break;

                          default:
                            /* No match. */
                          }
                        }
                      }
                      break;

                    case '5':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('6' == yyC) {

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyIndex);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = "int56";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("elementary type name expected", yyStart);
                            }
                          }
                        }
                      }
                      break;

                    case '6':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('4' == yyC) {

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyIndex);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = "int64";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("elementary type name expected", yyStart);
                            }
                          }
                        }
                      }
                      break;

                    case '7':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('2' == yyC) {

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyIndex);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = "int72";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("elementary type name expected", yyStart);
                            }
                          }
                        }
                      }
                      break;

                    case '8':
                      {
                        final int yyChoice2 = yyIndex;

                        // Nested alternative 1.

                        yyC = character(yyChoice2);
                        if (-1 != yyC) {
                          yyIndex = yyChoice2 + 1;

                          switch (yyC) {
                          case '0':
                            {
                              yyPredMatched = false;

                              yyPredResult = pidrest(yyIndex);
                              if (yyPredResult.hasValue()) {

                                yyPredMatched = true;
                              }

                              if (! yyPredMatched) {

                                yyValue = "int80";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              } else {
                                yyError = yyError.select("elementary type name expected", yyStart);
                              }
                            }
                            break;

                          case '8':
                            {
                              yyPredMatched = false;

                              yyPredResult = pidrest(yyIndex);
                              if (yyPredResult.hasValue()) {

                                yyPredMatched = true;
                              }

                              if (! yyPredMatched) {

                                yyValue = "int88";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              } else {
                                yyError = yyError.select("elementary type name expected", yyStart);
                              }
                            }
                            break;

                          default:
                            /* No match. */
                          }
                        }

                        // Nested alternative 2.

                        yyPredMatched = false;

                        yyPredResult = pidrest(yyChoice2);
                        if (yyPredResult.hasValue()) {

                          yyPredMatched = true;
                        }

                        if (! yyPredMatched) {

                          yyValue = "int8";

                          return new SemanticValue(yyValue, yyChoice2, yyError);
                        } else {
                          yyError = yyError.select("elementary type name expected", yyStart);
                        }
                      }
                      break;

                    case '9':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('6' == yyC) {

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyIndex);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = "int96";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("elementary type name expected", yyStart);
                            }
                          }
                        }
                      }
                      break;

                    case '1':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;

                          switch (yyC) {
                          case '0':
                            {
                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('4' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "int104";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                              }
                            }
                            break;

                          case '1':
                            {
                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('2' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "int112";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                              }
                            }
                            break;

                          case '2':
                            {
                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;

                                switch (yyC) {
                                case '0':
                                  {
                                    yyPredMatched = false;

                                    yyPredResult = pidrest(yyIndex);
                                    if (yyPredResult.hasValue()) {

                                      yyPredMatched = true;
                                    }

                                    if (! yyPredMatched) {

                                      yyValue = "int120";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("elementary type name expected", yyStart);
                                    }
                                  }
                                  break;

                                case '8':
                                  {
                                    yyPredMatched = false;

                                    yyPredResult = pidrest(yyIndex);
                                    if (yyPredResult.hasValue()) {

                                      yyPredMatched = true;
                                    }

                                    if (! yyPredMatched) {

                                      yyValue = "int128";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("elementary type name expected", yyStart);
                                    }
                                  }
                                  break;

                                default:
                                  /* No match. */
                                }
                              }
                            }
                            break;

                          case '3':
                            {
                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('6' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "int136";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                              }
                            }
                            break;

                          case '4':
                            {
                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('4' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "int144";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                              }
                            }
                            break;

                          case '5':
                            {
                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('2' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "int152";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                              }
                            }
                            break;

                          case '6':
                            {
                              final int yyChoice2 = yyIndex;

                              // Nested alternative 1.

                              yyC = character(yyChoice2);
                              if (-1 != yyC) {
                                yyIndex = yyChoice2 + 1;

                                switch (yyC) {
                                case '0':
                                  {
                                    yyPredMatched = false;

                                    yyPredResult = pidrest(yyIndex);
                                    if (yyPredResult.hasValue()) {

                                      yyPredMatched = true;
                                    }

                                    if (! yyPredMatched) {

                                      yyValue = "int160";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("elementary type name expected", yyStart);
                                    }
                                  }
                                  break;

                                case '8':
                                  {
                                    yyPredMatched = false;

                                    yyPredResult = pidrest(yyIndex);
                                    if (yyPredResult.hasValue()) {

                                      yyPredMatched = true;
                                    }

                                    if (! yyPredMatched) {

                                      yyValue = "int168";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("elementary type name expected", yyStart);
                                    }
                                  }
                                  break;

                                default:
                                  /* No match. */
                                }
                              }

                              // Nested alternative 2.

                              yyPredMatched = false;

                              yyPredResult = pidrest(yyChoice2);
                              if (yyPredResult.hasValue()) {

                                yyPredMatched = true;
                              }

                              if (! yyPredMatched) {

                                yyValue = "int16";

                                return new SemanticValue(yyValue, yyChoice2, yyError);
                              } else {
                                yyError = yyError.select("elementary type name expected", yyStart);
                              }
                            }
                            break;

                          case '7':
                            {
                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('6' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "int176";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                              }
                            }
                            break;

                          case '8':
                            {
                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('4' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "int184";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                              }
                            }
                            break;

                          case '9':
                            {
                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('2' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "int192";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                              }
                            }
                            break;

                          default:
                            /* No match. */
                          }
                        }
                      }
                      break;

                    default:
                      /* No match. */
                    }
                  }

                  // Nested alternative 2.

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyChoice1);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = "int";

                    return new SemanticValue(yyValue, yyChoice1, yyError);
                  } else {
                    yyError = yyError.select("elementary type name expected", yyStart);
                  }
                }
              }
            }
          }
        }
        break;

      case 'u':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('i' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('n' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('t' == yyC) {

                      final int yyChoice1 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice1);
                      if (-1 != yyC) {
                        yyIndex = yyChoice1 + 1;

                        switch (yyC) {
                        case '2':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;

                              switch (yyC) {
                              case '0':
                                {
                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;

                                    switch (yyC) {
                                    case '0':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "uint200";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '8':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "uint208";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    default:
                                      /* No match. */
                                    }
                                  }
                                }
                                break;

                              case '1':
                                {
                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('6' == yyC) {

                                      yyPredMatched = false;

                                      yyPredResult = pidrest(yyIndex);
                                      if (yyPredResult.hasValue()) {

                                        yyPredMatched = true;
                                      }

                                      if (! yyPredMatched) {

                                        yyValue = "uint216";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      } else {
                                        yyError = yyError.select("elementary type name expected", yyStart);
                                      }
                                    }
                                  }
                                }
                                break;

                              case '2':
                                {
                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('4' == yyC) {

                                      yyPredMatched = false;

                                      yyPredResult = pidrest(yyIndex);
                                      if (yyPredResult.hasValue()) {

                                        yyPredMatched = true;
                                      }

                                      if (! yyPredMatched) {

                                        yyValue = "uint224";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      } else {
                                        yyError = yyError.select("elementary type name expected", yyStart);
                                      }
                                    }
                                  }
                                }
                                break;

                              case '3':
                                {
                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('2' == yyC) {

                                      yyPredMatched = false;

                                      yyPredResult = pidrest(yyIndex);
                                      if (yyPredResult.hasValue()) {

                                        yyPredMatched = true;
                                      }

                                      if (! yyPredMatched) {

                                        yyValue = "uint232";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      } else {
                                        yyError = yyError.select("elementary type name expected", yyStart);
                                      }
                                    }
                                  }
                                }
                                break;

                              case '4':
                                {
                                  final int yyChoice2 = yyIndex;

                                  // Nested alternative 1.

                                  yyC = character(yyChoice2);
                                  if (-1 != yyC) {
                                    yyIndex = yyChoice2 + 1;

                                    switch (yyC) {
                                    case '0':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "uint240";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '8':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "uint248";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    default:
                                      /* No match. */
                                    }
                                  }

                                  // Nested alternative 2.

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyChoice2);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "uint24";

                                    return new SemanticValue(yyValue, yyChoice2, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                                break;

                              case '5':
                                {
                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('6' == yyC) {

                                      yyPredMatched = false;

                                      yyPredResult = pidrest(yyIndex);
                                      if (yyPredResult.hasValue()) {

                                        yyPredMatched = true;
                                      }

                                      if (! yyPredMatched) {

                                        yyValue = "uint256";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      } else {
                                        yyError = yyError.select("elementary type name expected", yyStart);
                                      }
                                    }
                                  }
                                }
                                break;

                              default:
                                /* No match. */
                              }
                            }
                          }
                          break;

                        case '3':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('2' == yyC) {

                                yyPredMatched = false;

                                yyPredResult = pidrest(yyIndex);
                                if (yyPredResult.hasValue()) {

                                  yyPredMatched = true;
                                }

                                if (! yyPredMatched) {

                                  yyValue = "uint32";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                } else {
                                  yyError = yyError.select("elementary type name expected", yyStart);
                                }
                              }
                            }
                          }
                          break;

                        case '4':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;

                              switch (yyC) {
                              case '0':
                                {
                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "uint40";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                                break;

                              case '8':
                                {
                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "uint48";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                                break;

                              default:
                                /* No match. */
                              }
                            }
                          }
                          break;

                        case '5':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('6' == yyC) {

                                yyPredMatched = false;

                                yyPredResult = pidrest(yyIndex);
                                if (yyPredResult.hasValue()) {

                                  yyPredMatched = true;
                                }

                                if (! yyPredMatched) {

                                  yyValue = "uint56";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                } else {
                                  yyError = yyError.select("elementary type name expected", yyStart);
                                }
                              }
                            }
                          }
                          break;

                        case '6':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('4' == yyC) {

                                yyPredMatched = false;

                                yyPredResult = pidrest(yyIndex);
                                if (yyPredResult.hasValue()) {

                                  yyPredMatched = true;
                                }

                                if (! yyPredMatched) {

                                  yyValue = "uint64";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                } else {
                                  yyError = yyError.select("elementary type name expected", yyStart);
                                }
                              }
                            }
                          }
                          break;

                        case '7':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('2' == yyC) {

                                yyPredMatched = false;

                                yyPredResult = pidrest(yyIndex);
                                if (yyPredResult.hasValue()) {

                                  yyPredMatched = true;
                                }

                                if (! yyPredMatched) {

                                  yyValue = "uint72";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                } else {
                                  yyError = yyError.select("elementary type name expected", yyStart);
                                }
                              }
                            }
                          }
                          break;

                        case '8':
                          {
                            final int yyChoice2 = yyIndex;

                            // Nested alternative 1.

                            yyC = character(yyChoice2);
                            if (-1 != yyC) {
                              yyIndex = yyChoice2 + 1;

                              switch (yyC) {
                              case '0':
                                {
                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "uint80";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                                break;

                              case '8':
                                {
                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "uint88";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                                break;

                              default:
                                /* No match. */
                              }
                            }

                            // Nested alternative 2.

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyChoice2);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = "uint8";

                              return new SemanticValue(yyValue, yyChoice2, yyError);
                            } else {
                              yyError = yyError.select("elementary type name expected", yyStart);
                            }
                          }
                          break;

                        case '9':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('6' == yyC) {

                                yyPredMatched = false;

                                yyPredResult = pidrest(yyIndex);
                                if (yyPredResult.hasValue()) {

                                  yyPredMatched = true;
                                }

                                if (! yyPredMatched) {

                                  yyValue = "uint96";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                } else {
                                  yyError = yyError.select("elementary type name expected", yyStart);
                                }
                              }
                            }
                          }
                          break;

                        case '1':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;

                              switch (yyC) {
                              case '0':
                                {
                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('4' == yyC) {

                                      yyPredMatched = false;

                                      yyPredResult = pidrest(yyIndex);
                                      if (yyPredResult.hasValue()) {

                                        yyPredMatched = true;
                                      }

                                      if (! yyPredMatched) {

                                        yyValue = "uint104";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      } else {
                                        yyError = yyError.select("elementary type name expected", yyStart);
                                      }
                                    }
                                  }
                                }
                                break;

                              case '1':
                                {
                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('2' == yyC) {

                                      yyPredMatched = false;

                                      yyPredResult = pidrest(yyIndex);
                                      if (yyPredResult.hasValue()) {

                                        yyPredMatched = true;
                                      }

                                      if (! yyPredMatched) {

                                        yyValue = "uint112";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      } else {
                                        yyError = yyError.select("elementary type name expected", yyStart);
                                      }
                                    }
                                  }
                                }
                                break;

                              case '2':
                                {
                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;

                                    switch (yyC) {
                                    case '0':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "uint120";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '8':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "uint128";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    default:
                                      /* No match. */
                                    }
                                  }
                                }
                                break;

                              case '3':
                                {
                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('6' == yyC) {

                                      yyPredMatched = false;

                                      yyPredResult = pidrest(yyIndex);
                                      if (yyPredResult.hasValue()) {

                                        yyPredMatched = true;
                                      }

                                      if (! yyPredMatched) {

                                        yyValue = "uint136";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      } else {
                                        yyError = yyError.select("elementary type name expected", yyStart);
                                      }
                                    }
                                  }
                                }
                                break;

                              case '4':
                                {
                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('4' == yyC) {

                                      yyPredMatched = false;

                                      yyPredResult = pidrest(yyIndex);
                                      if (yyPredResult.hasValue()) {

                                        yyPredMatched = true;
                                      }

                                      if (! yyPredMatched) {

                                        yyValue = "uint144";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      } else {
                                        yyError = yyError.select("elementary type name expected", yyStart);
                                      }
                                    }
                                  }
                                }
                                break;

                              case '5':
                                {
                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('2' == yyC) {

                                      yyPredMatched = false;

                                      yyPredResult = pidrest(yyIndex);
                                      if (yyPredResult.hasValue()) {

                                        yyPredMatched = true;
                                      }

                                      if (! yyPredMatched) {

                                        yyValue = "uint152";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      } else {
                                        yyError = yyError.select("elementary type name expected", yyStart);
                                      }
                                    }
                                  }
                                }
                                break;

                              case '6':
                                {
                                  final int yyChoice2 = yyIndex;

                                  // Nested alternative 1.

                                  yyC = character(yyChoice2);
                                  if (-1 != yyC) {
                                    yyIndex = yyChoice2 + 1;

                                    switch (yyC) {
                                    case '0':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "uint160";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    case '8':
                                      {
                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "uint168";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("elementary type name expected", yyStart);
                                        }
                                      }
                                      break;

                                    default:
                                      /* No match. */
                                    }
                                  }

                                  // Nested alternative 2.

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyChoice2);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "uint16";

                                    return new SemanticValue(yyValue, yyChoice2, yyError);
                                  } else {
                                    yyError = yyError.select("elementary type name expected", yyStart);
                                  }
                                }
                                break;

                              case '7':
                                {
                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('6' == yyC) {

                                      yyPredMatched = false;

                                      yyPredResult = pidrest(yyIndex);
                                      if (yyPredResult.hasValue()) {

                                        yyPredMatched = true;
                                      }

                                      if (! yyPredMatched) {

                                        yyValue = "uint176";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      } else {
                                        yyError = yyError.select("elementary type name expected", yyStart);
                                      }
                                    }
                                  }
                                }
                                break;

                              case '8':
                                {
                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('4' == yyC) {

                                      yyPredMatched = false;

                                      yyPredResult = pidrest(yyIndex);
                                      if (yyPredResult.hasValue()) {

                                        yyPredMatched = true;
                                      }

                                      if (! yyPredMatched) {

                                        yyValue = "uint184";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      } else {
                                        yyError = yyError.select("elementary type name expected", yyStart);
                                      }
                                    }
                                  }
                                }
                                break;

                              case '9':
                                {
                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('2' == yyC) {

                                      yyPredMatched = false;

                                      yyPredResult = pidrest(yyIndex);
                                      if (yyPredResult.hasValue()) {

                                        yyPredMatched = true;
                                      }

                                      if (! yyPredMatched) {

                                        yyValue = "uint192";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      } else {
                                        yyError = yyError.select("elementary type name expected", yyStart);
                                      }
                                    }
                                  }
                                }
                                break;

                              default:
                                /* No match. */
                              }
                            }
                          }
                          break;

                        default:
                          /* No match. */
                        }
                      }

                      // Nested alternative 2.

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyChoice1);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = "uint";

                        return new SemanticValue(yyValue, yyChoice1, yyError);
                      } else {
                        yyError = yyError.select("elementary type name expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyResult = pFixed(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pUfixed(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("elementary type name expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.Fixed.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFixed(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pfixed(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyOption1  = yyResult.index;

      yyResult = pDecimalDigits(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyC = character(yyResult.index);
        if ('x' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pDecimalDigits(yyIndex);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }
        }
      }

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    yyError = yyError.select("fixed expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.Ufixed.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUfixed(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pufixed(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyOption1  = yyResult.index;

      yyResult = pDecimalDigits(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyC = character(yyResult.index);
        if ('x' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pDecimalDigits(yyIndex);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }
        }
      }

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    yyError = yyError.select("ufixed expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.UserDefinedTypeName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUserDefinedTypeName(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fUserDefinedTypeName) 
      yyColumn.chunk5.fUserDefinedTypeName = pUserDefinedTypeName$1(yyStart);
    return yyColumn.chunk5.fUserDefinedTypeName;
  }

  /** Actually parse Literal.UserDefinedTypeName. */
  private Result pUserDefinedTypeName$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    TypeName   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared31(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pUserDefinedTypeName$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Id> a2s = yyResult.semanticValue();

        List<Id> names;
        if (a2s.list().isEmpty()) names = list(a1);
        else names = cons(a1, a2s.list());
        yyValue = new UserDefinedTypeName(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)),
        toList(names));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.saf.parser.SOL.UserDefinedTypeName$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUserDefinedTypeName$$Star1(final int yyStart) 
    throws IOException {

    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fUserDefinedTypeName$$Star1) 
      yyColumn.chunk5.fUserDefinedTypeName$$Star1 = pUserDefinedTypeName$$Star1$1(yyStart);
    return yyColumn.chunk5.fUserDefinedTypeName$$Star1;
  }

  /** Actually parse kr.ac.kaist.saf.parser.SOL.UserDefinedTypeName$$Star1. */
  private Result pUserDefinedTypeName$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pdot(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = p$$Shared31(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id v$el$1 = yyResult.semanticValue();

        yyResult = pUserDefinedTypeName$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Id> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Id>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.Mapping.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMapping(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    TypeName   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pmapping(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popenparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pElementaryTypeName(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyBase = yyResult.index;
                yyC    = character(yyBase);
                if ('=' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyC = character(yyIndex);
                  if ('>' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyResult = pw(yyIndex);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pTypeName(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        TypeName a2 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;

                        yyResult = pw(yyOption1);
                        yyError  = yyResult.select(yyError, yyOption1);
                        if (yyResult.hasValue()) {

                          yyResult = ppayable(yyResult.index);
                          yyError  = yyResult.select(yyError, yyOption1);
                          if (yyResult.hasValue()) {

                            yyOption1  = yyResult.index;
                          }
                        }

                        yyResult = pw(yyOption1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pcloseparen(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyValue = new Mapping(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount+1)), a1, a2);

                            return yyResult.createValue(yyValue, yyError);
                          }
                        }
                      }
                    }
                  } else {
                    yyError = yyError.select("'=>' expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("'=>' expected", yyBase);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.FunctionTypeName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunctionTypeName(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    int        yyOption1;
    TypeName   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pfunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pFunctionTypeParameterList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              final int yyChoice1 = yyResult.index;

              // Nested alternative 1.

              yyResult = pinternal(yyChoice1);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {

                yyRepetition1 = yyResult.index;
                continue;
              }

              // Nested alternative 2.

              yyResult = pexternal(yyChoice1);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {

                yyRepetition1 = yyResult.index;
                continue;
              }

              // Nested alternative 3.

              yyResult = pStateMutability(yyChoice1);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {

                yyRepetition1 = yyResult.index;
                continue;
              }
            }
            break;
          }

          yyOption1  = yyRepetition1;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyResult = preturns(yyResult.index);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {

                yyResult = pFunctionTypeParameterList(yyResult.index);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                }
              }
            }
          }

          yyValue = new FunctionTypeName(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount+1)));

          return new SemanticValue(yyValue, yyOption1, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.FunctionTypeParameterList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunctionTypeParameterList(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyOption1  = yyIndex;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyResult = pFunctionTypeParameter(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyBase = yyResult.index;
              yyC    = character(yyBase);
              if (',' == yyC) {
                yyIndex = yyResult.index + 1;

                yyResult = pw(yyIndex);
                yyError  = yyResult.select(yyError, yyRepetition1);
                if (yyResult.hasValue()) {

                  yyResult = pFunctionTypeParameter(yyResult.index);
                  yyError  = yyResult.select(yyError, yyRepetition1);
                  if (yyResult.hasValue()) {

                    yyRepetition1 = yyResult.index;
                    continue;
                  }
                }
              } else {
                yyError = yyError.select("',' expected", yyBase);
              }
            }
            break;
          }

          yyOption1  = yyRepetition1;
        }
      }

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if (')' == yyC) {
          yyIndex = yyResult.index + 1;

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("function type parameter list expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.FunctionTypeParameter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunctionTypeParameter(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypeName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyResult = pStorageLocation(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }
      }

      yyValue = null;

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.IdOrList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdOrList(final int yyStart) throws IOException {
    Result     yyResult;
    List<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared11(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = p$$Shared31(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = list(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.OptIds.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOptIds(final int yyStart) throws IOException {
    Result           yyResult;
    List<Option<Id>> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pOptIdList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.OptIdList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOptIdList(final int yyStart) throws IOException {
    SOLColumn yyColumn = (SOLColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fOptIdList) 
      yyColumn.chunk5.fOptIdList = pOptIdList$1(yyStart);
    return yyColumn.chunk5.fOptIdList;
  }

  /** Actually parse Literal.OptIdList. */
  private Result pOptIdList$1(final int yyStart) throws IOException {
    Result           yyResult;
    List<Option<Id>> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared31(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pOptIdList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Option<Id>> a2 = yyResult.semanticValue();

              yyValue = cons(Some.<Id>apply(a1), a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pOptIdList(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Option<Id>> a1 = yyResult.semanticValue();

            yyValue = cons(Option.<Id>apply(null), a1);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 3.

    yyResult = p$$Shared31(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcloseparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = list(Some.<Id>apply(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyResult = pcloseparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Collections.<Option<Id>>emptyList();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared14.
   * This nonterminal represents the duplicate productions Identifier.id 
   * and Identifier.idname.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared14(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared14$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String s = yyResult.semanticValue();

      if (!SOLIDITY_RESERVED.contains(s)) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.saf.parser.SOL.$$Shared14$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared14$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pidstart(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      while (true) {

        yyResult = pidrest(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
        break;
      }

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.idstart.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pidstart(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z')) ||
          ('\u00aa' == yyC) ||
          ('\u00b5' == yyC) ||
          ('\u00ba' == yyC) ||
          (('\u00c0' <= yyC) && (yyC <= '\u00d6')) ||
          (('\u00d8' <= yyC) && (yyC <= '\u00f6')) ||
          (('\u00f8' <= yyC) && (yyC <= '\u02c1')) ||
          (('\u02c6' <= yyC) && (yyC <= '\u02d1')) ||
          (('\u02e0' <= yyC) && (yyC <= '\u02e4')) ||
          ('\u02ee' == yyC) ||
          (('\u037a' <= yyC) && (yyC <= '\u037d')) ||
          ('\u0386' == yyC) ||
          (('\u0388' <= yyC) && (yyC <= '\u038a')) ||
          ('\u038c' == yyC) ||
          (('\u038e' <= yyC) && (yyC <= '\u03a1')) ||
          (('\u03a3' <= yyC) && (yyC <= '\u03ce')) ||
          (('\u03d0' <= yyC) && (yyC <= '\u03f5')) ||
          (('\u03f7' <= yyC) && (yyC <= '\u0481')) ||
          (('\u048a' <= yyC) && (yyC <= '\u0513')) ||
          (('\u0531' <= yyC) && (yyC <= '\u0556')) ||
          ('\u0559' == yyC) ||
          (('\u0561' <= yyC) && (yyC <= '\u0587')) ||
          (('\u05d0' <= yyC) && (yyC <= '\u05ea')) ||
          (('\u05f0' <= yyC) && (yyC <= '\u05f2')) ||
          (('\u0621' <= yyC) && (yyC <= '\u063a')) ||
          (('\u0640' <= yyC) && (yyC <= '\u064a')) ||
          (('\u066e' <= yyC) && (yyC <= '\u066f')) ||
          (('\u0671' <= yyC) && (yyC <= '\u06d3')) ||
          ('\u06d5' == yyC) ||
          (('\u06e5' <= yyC) && (yyC <= '\u06e6')) ||
          (('\u06ee' <= yyC) && (yyC <= '\u06ef')) ||
          (('\u06fa' <= yyC) && (yyC <= '\u06fc')) ||
          ('\u06ff' == yyC) ||
          ('\u0710' == yyC) ||
          (('\u0712' <= yyC) && (yyC <= '\u072f')) ||
          (('\u074d' <= yyC) && (yyC <= '\u076d')) ||
          (('\u0780' <= yyC) && (yyC <= '\u07a5')) ||
          ('\u07b1' == yyC) ||
          (('\u07ca' <= yyC) && (yyC <= '\u07ea')) ||
          (('\u07f4' <= yyC) && (yyC <= '\u07f5')) ||
          ('\u07fa' == yyC) ||
          (('\u0904' <= yyC) && (yyC <= '\u0939')) ||
          ('\u093d' == yyC) ||
          ('\u0950' == yyC) ||
          (('\u0958' <= yyC) && (yyC <= '\u0961')) ||
          (('\u097b' <= yyC) && (yyC <= '\u097f')) ||
          (('\u0985' <= yyC) && (yyC <= '\u098c')) ||
          (('\u098f' <= yyC) && (yyC <= '\u0990')) ||
          (('\u0993' <= yyC) && (yyC <= '\u09a8')) ||
          (('\u09aa' <= yyC) && (yyC <= '\u09b0')) ||
          ('\u09b2' == yyC) ||
          (('\u09b6' <= yyC) && (yyC <= '\u09b9')) ||
          ('\u09bd' == yyC) ||
          ('\u09ce' == yyC) ||
          (('\u09dc' <= yyC) && (yyC <= '\u09dd')) ||
          (('\u09df' <= yyC) && (yyC <= '\u09e1')) ||
          (('\u09f0' <= yyC) && (yyC <= '\u09f1')) ||
          (('\u0a05' <= yyC) && (yyC <= '\u0a0a')) ||
          (('\u0a0f' <= yyC) && (yyC <= '\u0a10')) ||
          (('\u0a13' <= yyC) && (yyC <= '\u0a28')) ||
          (('\u0a2a' <= yyC) && (yyC <= '\u0a30')) ||
          (('\u0a32' <= yyC) && (yyC <= '\u0a33')) ||
          (('\u0a35' <= yyC) && (yyC <= '\u0a36')) ||
          (('\u0a38' <= yyC) && (yyC <= '\u0a39')) ||
          (('\u0a59' <= yyC) && (yyC <= '\u0a5c')) ||
          ('\u0a5e' == yyC) ||
          (('\u0a72' <= yyC) && (yyC <= '\u0a74')) ||
          (('\u0a85' <= yyC) && (yyC <= '\u0a8d')) ||
          (('\u0a8f' <= yyC) && (yyC <= '\u0a91')) ||
          (('\u0a93' <= yyC) && (yyC <= '\u0aa8')) ||
          (('\u0aaa' <= yyC) && (yyC <= '\u0ab0')) ||
          (('\u0ab2' <= yyC) && (yyC <= '\u0ab3')) ||
          (('\u0ab5' <= yyC) && (yyC <= '\u0ab9')) ||
          ('\u0abd' == yyC) ||
          ('\u0ad0' == yyC) ||
          (('\u0ae0' <= yyC) && (yyC <= '\u0ae1')) ||
          (('\u0b05' <= yyC) && (yyC <= '\u0b0c')) ||
          (('\u0b0f' <= yyC) && (yyC <= '\u0b10')) ||
          (('\u0b13' <= yyC) && (yyC <= '\u0b28')) ||
          (('\u0b2a' <= yyC) && (yyC <= '\u0b30')) ||
          (('\u0b32' <= yyC) && (yyC <= '\u0b33')) ||
          (('\u0b35' <= yyC) && (yyC <= '\u0b39')) ||
          ('\u0b3d' == yyC) ||
          (('\u0b5c' <= yyC) && (yyC <= '\u0b5d')) ||
          (('\u0b5f' <= yyC) && (yyC <= '\u0b61')) ||
          ('\u0b71' == yyC) ||
          ('\u0b83' == yyC) ||
          (('\u0b85' <= yyC) && (yyC <= '\u0b8a')) ||
          (('\u0b8e' <= yyC) && (yyC <= '\u0b90')) ||
          (('\u0b92' <= yyC) && (yyC <= '\u0b95')) ||
          (('\u0b99' <= yyC) && (yyC <= '\u0b9a')) ||
          ('\u0b9c' == yyC) ||
          (('\u0b9e' <= yyC) && (yyC <= '\u0b9f')) ||
          (('\u0ba3' <= yyC) && (yyC <= '\u0ba4')) ||
          (('\u0ba8' <= yyC) && (yyC <= '\u0baa')) ||
          (('\u0bae' <= yyC) && (yyC <= '\u0bb9')) ||
          (('\u0c05' <= yyC) && (yyC <= '\u0c0c')) ||
          (('\u0c0e' <= yyC) && (yyC <= '\u0c10')) ||
          (('\u0c12' <= yyC) && (yyC <= '\u0c28')) ||
          (('\u0c2a' <= yyC) && (yyC <= '\u0c33')) ||
          (('\u0c35' <= yyC) && (yyC <= '\u0c39')) ||
          (('\u0c60' <= yyC) && (yyC <= '\u0c61')) ||
          (('\u0c85' <= yyC) && (yyC <= '\u0c8c')) ||
          (('\u0c8e' <= yyC) && (yyC <= '\u0c90')) ||
          (('\u0c92' <= yyC) && (yyC <= '\u0ca8')) ||
          (('\u0caa' <= yyC) && (yyC <= '\u0cb3')) ||
          (('\u0cb5' <= yyC) && (yyC <= '\u0cb9')) ||
          ('\u0cbd' == yyC) ||
          ('\u0cde' == yyC) ||
          (('\u0ce0' <= yyC) && (yyC <= '\u0ce1')) ||
          (('\u0d05' <= yyC) && (yyC <= '\u0d0c')) ||
          (('\u0d0e' <= yyC) && (yyC <= '\u0d10')) ||
          (('\u0d12' <= yyC) && (yyC <= '\u0d28')) ||
          (('\u0d2a' <= yyC) && (yyC <= '\u0d39')) ||
          (('\u0d60' <= yyC) && (yyC <= '\u0d61')) ||
          (('\u0d85' <= yyC) && (yyC <= '\u0d96')) ||
          (('\u0d9a' <= yyC) && (yyC <= '\u0db1')) ||
          (('\u0db3' <= yyC) && (yyC <= '\u0dbb')) ||
          ('\u0dbd' == yyC) ||
          (('\u0dc0' <= yyC) && (yyC <= '\u0dc6')) ||
          (('\u0e01' <= yyC) && (yyC <= '\u0e30')) ||
          (('\u0e32' <= yyC) && (yyC <= '\u0e33')) ||
          (('\u0e40' <= yyC) && (yyC <= '\u0e46')) ||
          (('\u0e81' <= yyC) && (yyC <= '\u0e82')) ||
          ('\u0e84' == yyC) ||
          (('\u0e87' <= yyC) && (yyC <= '\u0e88')) ||
          ('\u0e8a' == yyC) ||
          ('\u0e8d' == yyC) ||
          (('\u0e94' <= yyC) && (yyC <= '\u0e97')) ||
          (('\u0e99' <= yyC) && (yyC <= '\u0e9f')) ||
          (('\u0ea1' <= yyC) && (yyC <= '\u0ea3')) ||
          ('\u0ea5' == yyC) ||
          ('\u0ea7' == yyC) ||
          (('\u0eaa' <= yyC) && (yyC <= '\u0eab')) ||
          (('\u0ead' <= yyC) && (yyC <= '\u0eb0')) ||
          (('\u0eb2' <= yyC) && (yyC <= '\u0eb3')) ||
          ('\u0ebd' == yyC) ||
          (('\u0ec0' <= yyC) && (yyC <= '\u0ec4')) ||
          ('\u0ec6' == yyC) ||
          (('\u0edc' <= yyC) && (yyC <= '\u0edd')) ||
          ('\u0f00' == yyC) ||
          (('\u0f40' <= yyC) && (yyC <= '\u0f47')) ||
          (('\u0f49' <= yyC) && (yyC <= '\u0f6a')) ||
          (('\u0f88' <= yyC) && (yyC <= '\u0f8b')) ||
          (('\u1000' <= yyC) && (yyC <= '\u1021')) ||
          (('\u1023' <= yyC) && (yyC <= '\u1027')) ||
          (('\u1029' <= yyC) && (yyC <= '\u102a')) ||
          (('\u1050' <= yyC) && (yyC <= '\u1055')) ||
          (('\u10a0' <= yyC) && (yyC <= '\u10c5')) ||
          (('\u10d0' <= yyC) && (yyC <= '\u10fa')) ||
          ('\u10fc' == yyC) ||
          (('\u1100' <= yyC) && (yyC <= '\u1159')) ||
          (('\u115f' <= yyC) && (yyC <= '\u11a2')) ||
          (('\u11a8' <= yyC) && (yyC <= '\u11f9')) ||
          (('\u1200' <= yyC) && (yyC <= '\u1248')) ||
          (('\u124a' <= yyC) && (yyC <= '\u124d')) ||
          (('\u1250' <= yyC) && (yyC <= '\u1256')) ||
          ('\u1258' == yyC) ||
          (('\u125a' <= yyC) && (yyC <= '\u125d')) ||
          (('\u1260' <= yyC) && (yyC <= '\u1288')) ||
          (('\u128a' <= yyC) && (yyC <= '\u128d')) ||
          (('\u1290' <= yyC) && (yyC <= '\u12b0')) ||
          (('\u12b2' <= yyC) && (yyC <= '\u12b5')) ||
          (('\u12b8' <= yyC) && (yyC <= '\u12be')) ||
          ('\u12c0' == yyC) ||
          (('\u12c2' <= yyC) && (yyC <= '\u12c5')) ||
          (('\u12c8' <= yyC) && (yyC <= '\u12d6')) ||
          (('\u12d8' <= yyC) && (yyC <= '\u1310')) ||
          (('\u1312' <= yyC) && (yyC <= '\u1315')) ||
          (('\u1318' <= yyC) && (yyC <= '\u135a')) ||
          (('\u1380' <= yyC) && (yyC <= '\u138f')) ||
          (('\u13a0' <= yyC) && (yyC <= '\u13f4')) ||
          (('\u1401' <= yyC) && (yyC <= '\u166c')) ||
          (('\u166f' <= yyC) && (yyC <= '\u1676')) ||
          (('\u1681' <= yyC) && (yyC <= '\u169a')) ||
          (('\u16a0' <= yyC) && (yyC <= '\u16ea')) ||
          (('\u16ee' <= yyC) && (yyC <= '\u16f0')) ||
          (('\u1700' <= yyC) && (yyC <= '\u170c')) ||
          (('\u170e' <= yyC) && (yyC <= '\u1711')) ||
          (('\u1720' <= yyC) && (yyC <= '\u1731')) ||
          (('\u1740' <= yyC) && (yyC <= '\u1751')) ||
          (('\u1760' <= yyC) && (yyC <= '\u176c')) ||
          (('\u176e' <= yyC) && (yyC <= '\u1770')) ||
          (('\u1780' <= yyC) && (yyC <= '\u17b3')) ||
          ('\u17d7' == yyC) ||
          ('\u17dc' == yyC) ||
          (('\u1820' <= yyC) && (yyC <= '\u1877')) ||
          (('\u1880' <= yyC) && (yyC <= '\u18a8')) ||
          (('\u1900' <= yyC) && (yyC <= '\u191c')) ||
          (('\u1950' <= yyC) && (yyC <= '\u196d')) ||
          (('\u1970' <= yyC) && (yyC <= '\u1974')) ||
          (('\u1980' <= yyC) && (yyC <= '\u19a9')) ||
          (('\u19c1' <= yyC) && (yyC <= '\u19c7')) ||
          (('\u1a00' <= yyC) && (yyC <= '\u1a16')) ||
          (('\u1b05' <= yyC) && (yyC <= '\u1b33')) ||
          (('\u1b45' <= yyC) && (yyC <= '\u1b4b')) ||
          (('\u1d00' <= yyC) && (yyC <= '\u1dbf')) ||
          (('\u1e00' <= yyC) && (yyC <= '\u1e9b')) ||
          (('\u1ea0' <= yyC) && (yyC <= '\u1ef9')) ||
          (('\u1f00' <= yyC) && (yyC <= '\u1f15')) ||
          (('\u1f18' <= yyC) && (yyC <= '\u1f1d')) ||
          (('\u1f20' <= yyC) && (yyC <= '\u1f45')) ||
          (('\u1f48' <= yyC) && (yyC <= '\u1f4d')) ||
          (('\u1f50' <= yyC) && (yyC <= '\u1f57')) ||
          ('\u1f59' == yyC) ||
          ('\u1f5b' == yyC) ||
          ('\u1f5d' == yyC) ||
          (('\u1f5f' <= yyC) && (yyC <= '\u1f7d')) ||
          (('\u1f80' <= yyC) && (yyC <= '\u1fb4')) ||
          (('\u1fb6' <= yyC) && (yyC <= '\u1fbc')) ||
          ('\u1fbe' == yyC) ||
          (('\u1fc2' <= yyC) && (yyC <= '\u1fc4')) ||
          (('\u1fc6' <= yyC) && (yyC <= '\u1fcc')) ||
          (('\u1fd0' <= yyC) && (yyC <= '\u1fd3')) ||
          (('\u1fd6' <= yyC) && (yyC <= '\u1fdb')) ||
          (('\u1fe0' <= yyC) && (yyC <= '\u1fec')) ||
          (('\u1ff2' <= yyC) && (yyC <= '\u1ff4')) ||
          (('\u1ff6' <= yyC) && (yyC <= '\u1ffc')) ||
          ('\u2071' == yyC) ||
          ('\u207f' == yyC) ||
          (('\u2090' <= yyC) && (yyC <= '\u2094')) ||
          ('\u2102' == yyC) ||
          ('\u2107' == yyC) ||
          (('\u210a' <= yyC) && (yyC <= '\u2113')) ||
          ('\u2115' == yyC) ||
          (('\u2119' <= yyC) && (yyC <= '\u211d')) ||
          ('\u2124' == yyC) ||
          ('\u2126' == yyC) ||
          ('\u2128' == yyC) ||
          (('\u212a' <= yyC) && (yyC <= '\u212d')) ||
          (('\u212f' <= yyC) && (yyC <= '\u2139')) ||
          (('\u213c' <= yyC) && (yyC <= '\u213f')) ||
          (('\u2145' <= yyC) && (yyC <= '\u2149')) ||
          ('\u214e' == yyC) ||
          (('\u2160' <= yyC) && (yyC <= '\u2184')) ||
          (('\u2c00' <= yyC) && (yyC <= '\u2c2e')) ||
          (('\u2c30' <= yyC) && (yyC <= '\u2c5e')) ||
          (('\u2c60' <= yyC) && (yyC <= '\u2c6c')) ||
          (('\u2c74' <= yyC) && (yyC <= '\u2c77')) ||
          (('\u2c80' <= yyC) && (yyC <= '\u2ce4')) ||
          (('\u2d00' <= yyC) && (yyC <= '\u2d25')) ||
          (('\u2d30' <= yyC) && (yyC <= '\u2d65')) ||
          ('\u2d6f' == yyC) ||
          (('\u2d80' <= yyC) && (yyC <= '\u2d96')) ||
          (('\u2da0' <= yyC) && (yyC <= '\u2da6')) ||
          (('\u2da8' <= yyC) && (yyC <= '\u2dae')) ||
          (('\u2db0' <= yyC) && (yyC <= '\u2db6')) ||
          (('\u2db8' <= yyC) && (yyC <= '\u2dbe')) ||
          (('\u2dc0' <= yyC) && (yyC <= '\u2dc6')) ||
          (('\u2dc8' <= yyC) && (yyC <= '\u2dce')) ||
          (('\u2dd0' <= yyC) && (yyC <= '\u2dd6')) ||
          (('\u2dd8' <= yyC) && (yyC <= '\u2dde')) ||
          (('\u3005' <= yyC) && (yyC <= '\u3007')) ||
          (('\u3021' <= yyC) && (yyC <= '\u3029')) ||
          (('\u3031' <= yyC) && (yyC <= '\u3035')) ||
          (('\u3038' <= yyC) && (yyC <= '\u303c')) ||
          (('\u3041' <= yyC) && (yyC <= '\u3096')) ||
          (('\u309d' <= yyC) && (yyC <= '\u309f')) ||
          (('\u30a1' <= yyC) && (yyC <= '\u30fa')) ||
          (('\u30fc' <= yyC) && (yyC <= '\u30ff')) ||
          (('\u3105' <= yyC) && (yyC <= '\u312c')) ||
          (('\u3131' <= yyC) && (yyC <= '\u318e')) ||
          (('\u31a0' <= yyC) && (yyC <= '\u31b7')) ||
          (('\u31f0' <= yyC) && (yyC <= '\u31ff')) ||
          (('\u3400' <= yyC) && (yyC <= '\u4db5')) ||
          (('\u4e00' <= yyC) && (yyC <= '\u9fbb')) ||
          (('\ua000' <= yyC) && (yyC <= '\ua48c')) ||
          (('\ua717' <= yyC) && (yyC <= '\ua71a')) ||
          (('\ua800' <= yyC) && (yyC <= '\ua801')) ||
          (('\ua803' <= yyC) && (yyC <= '\ua805')) ||
          (('\ua807' <= yyC) && (yyC <= '\ua80a')) ||
          (('\ua80c' <= yyC) && (yyC <= '\ua822')) ||
          (('\ua840' <= yyC) && (yyC <= '\ua873')) ||
          (('\uac00' <= yyC) && (yyC <= '\ud7a3')) ||
          (('\uf900' <= yyC) && (yyC <= '\ufa2d')) ||
          (('\ufa30' <= yyC) && (yyC <= '\ufa6a')) ||
          (('\ufa70' <= yyC) && (yyC <= '\ufad9')) ||
          (('\ufb00' <= yyC) && (yyC <= '\ufb06')) ||
          (('\ufb13' <= yyC) && (yyC <= '\ufb17')) ||
          ('\ufb1d' == yyC) ||
          (('\ufb1f' <= yyC) && (yyC <= '\ufb28')) ||
          (('\ufb2a' <= yyC) && (yyC <= '\ufb36')) ||
          (('\ufb38' <= yyC) && (yyC <= '\ufb3c')) ||
          ('\ufb3e' == yyC) ||
          (('\ufb40' <= yyC) && (yyC <= '\ufb41')) ||
          (('\ufb43' <= yyC) && (yyC <= '\ufb44')) ||
          (('\ufb46' <= yyC) && (yyC <= '\ufbb1')) ||
          (('\ufbd3' <= yyC) && (yyC <= '\ufd3d')) ||
          (('\ufd50' <= yyC) && (yyC <= '\ufd8f')) ||
          (('\ufd92' <= yyC) && (yyC <= '\ufdc7')) ||
          (('\ufdf0' <= yyC) && (yyC <= '\ufdfb')) ||
          (('\ufe70' <= yyC) && (yyC <= '\ufe74')) ||
          (('\ufe76' <= yyC) && (yyC <= '\ufefc')) ||
          (('\uff21' <= yyC) && (yyC <= '\uff3a')) ||
          (('\uff41' <= yyC) && (yyC <= '\uff5a')) ||
          (('\uff66' <= yyC) && (yyC <= '\uffbe')) ||
          (('\uffc2' <= yyC) && (yyC <= '\uffc7')) ||
          (('\uffca' <= yyC) && (yyC <= '\uffcf')) ||
          (('\uffd2' <= yyC) && (yyC <= '\uffd7')) ||
          (('\uffda' <= yyC) && (yyC <= '\uffdc'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud800':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc0b')) ||
                (('\udc0d' <= yyC) && (yyC <= '\udc26')) ||
                (('\udc28' <= yyC) && (yyC <= '\udc3a')) ||
                (('\udc3c' <= yyC) && (yyC <= '\udc3d')) ||
                (('\udc3f' <= yyC) && (yyC <= '\udc4d')) ||
                (('\udc50' <= yyC) && (yyC <= '\udc5d')) ||
                (('\udc80' <= yyC) && (yyC <= '\udcfa')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd74')) ||
                (('\udf00' <= yyC) && (yyC <= '\udf1e')) ||
                (('\udf30' <= yyC) && (yyC <= '\udf4a')) ||
                (('\udf80' <= yyC) && (yyC <= '\udf9d')) ||
                (('\udfa0' <= yyC) && (yyC <= '\udfc3')) ||
                (('\udfc8' <= yyC) && (yyC <= '\udfcf')) ||
                (('\udfd1' <= yyC) && (yyC <= '\udfd5'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc9d')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc05')) ||
                ('\udc08' == yyC) ||
                (('\udc0a' <= yyC) && (yyC <= '\udc35')) ||
                (('\udc37' <= yyC) && (yyC <= '\udc38')) ||
                ('\udc3c' == yyC) ||
                ('\udc3f' == yyC) ||
                (('\udd00' <= yyC) && (yyC <= '\udd15')) ||
                ('\ude00' == yyC) ||
                (('\ude10' <= yyC) && (yyC <= '\ude13')) ||
                (('\ude15' <= yyC) && (yyC <= '\ude17')) ||
                (('\ude19' <= yyC) && (yyC <= '\ude33'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud808':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udf6e')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud809':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc62')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc54')) ||
                (('\udc56' <= yyC) && (yyC <= '\udc9c')) ||
                (('\udc9e' <= yyC) && (yyC <= '\udc9f')) ||
                ('\udca2' == yyC) ||
                (('\udca5' <= yyC) && (yyC <= '\udca6')) ||
                (('\udca9' <= yyC) && (yyC <= '\udcac')) ||
                (('\udcae' <= yyC) && (yyC <= '\udcb9')) ||
                ('\udcbb' == yyC) ||
                (('\udcbd' <= yyC) && (yyC <= '\udcc3')) ||
                (('\udcc5' <= yyC) && (yyC <= '\udd05')) ||
                (('\udd07' <= yyC) && (yyC <= '\udd0a')) ||
                (('\udd0d' <= yyC) && (yyC <= '\udd14')) ||
                (('\udd16' <= yyC) && (yyC <= '\udd1c')) ||
                (('\udd1e' <= yyC) && (yyC <= '\udd39')) ||
                (('\udd3b' <= yyC) && (yyC <= '\udd3e')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd44')) ||
                ('\udd46' == yyC) ||
                (('\udd4a' <= yyC) && (yyC <= '\udd50')) ||
                (('\udd52' <= yyC) && (yyC <= '\udea5')) ||
                (('\udea8' <= yyC) && (yyC <= '\udec0')) ||
                (('\udec2' <= yyC) && (yyC <= '\udeda')) ||
                (('\udedc' <= yyC) && (yyC <= '\udefa')) ||
                (('\udefc' <= yyC) && (yyC <= '\udf14')) ||
                (('\udf16' <= yyC) && (yyC <= '\udf34')) ||
                (('\udf36' <= yyC) && (yyC <= '\udf4e')) ||
                (('\udf50' <= yyC) && (yyC <= '\udf6e')) ||
                (('\udf70' <= yyC) && (yyC <= '\udf88')) ||
                (('\udf8a' <= yyC) && (yyC <= '\udfa8')) ||
                (('\udfaa' <= yyC) && (yyC <= '\udfc2')) ||
                (('\udfc4' <= yyC) && (yyC <= '\udfcb'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud840':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\uded6')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud87e':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\ude1d')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '$':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '_':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\\':
        {
          yyResult = pUnicodeEscapeSequence(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("idstart expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.idrest.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pidrest(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z')) ||
          ('\u00aa' == yyC) ||
          ('\u00b5' == yyC) ||
          ('\u00ba' == yyC) ||
          (('\u00c0' <= yyC) && (yyC <= '\u00d6')) ||
          (('\u00d8' <= yyC) && (yyC <= '\u00f6')) ||
          (('\u00f8' <= yyC) && (yyC <= '\u02c1')) ||
          (('\u02c6' <= yyC) && (yyC <= '\u02d1')) ||
          (('\u02e0' <= yyC) && (yyC <= '\u02e4')) ||
          ('\u02ee' == yyC) ||
          (('\u037a' <= yyC) && (yyC <= '\u037d')) ||
          ('\u0386' == yyC) ||
          (('\u0388' <= yyC) && (yyC <= '\u038a')) ||
          ('\u038c' == yyC) ||
          (('\u038e' <= yyC) && (yyC <= '\u03a1')) ||
          (('\u03a3' <= yyC) && (yyC <= '\u03ce')) ||
          (('\u03d0' <= yyC) && (yyC <= '\u03f5')) ||
          (('\u03f7' <= yyC) && (yyC <= '\u0481')) ||
          (('\u048a' <= yyC) && (yyC <= '\u0513')) ||
          (('\u0531' <= yyC) && (yyC <= '\u0556')) ||
          ('\u0559' == yyC) ||
          (('\u0561' <= yyC) && (yyC <= '\u0587')) ||
          (('\u05d0' <= yyC) && (yyC <= '\u05ea')) ||
          (('\u05f0' <= yyC) && (yyC <= '\u05f2')) ||
          (('\u0621' <= yyC) && (yyC <= '\u063a')) ||
          (('\u0640' <= yyC) && (yyC <= '\u064a')) ||
          (('\u066e' <= yyC) && (yyC <= '\u066f')) ||
          (('\u0671' <= yyC) && (yyC <= '\u06d3')) ||
          ('\u06d5' == yyC) ||
          (('\u06e5' <= yyC) && (yyC <= '\u06e6')) ||
          (('\u06ee' <= yyC) && (yyC <= '\u06ef')) ||
          (('\u06fa' <= yyC) && (yyC <= '\u06fc')) ||
          ('\u06ff' == yyC) ||
          ('\u0710' == yyC) ||
          (('\u0712' <= yyC) && (yyC <= '\u072f')) ||
          (('\u074d' <= yyC) && (yyC <= '\u076d')) ||
          (('\u0780' <= yyC) && (yyC <= '\u07a5')) ||
          ('\u07b1' == yyC) ||
          (('\u07ca' <= yyC) && (yyC <= '\u07ea')) ||
          (('\u07f4' <= yyC) && (yyC <= '\u07f5')) ||
          ('\u07fa' == yyC) ||
          (('\u0904' <= yyC) && (yyC <= '\u0939')) ||
          ('\u093d' == yyC) ||
          ('\u0950' == yyC) ||
          (('\u0958' <= yyC) && (yyC <= '\u0961')) ||
          (('\u097b' <= yyC) && (yyC <= '\u097f')) ||
          (('\u0985' <= yyC) && (yyC <= '\u098c')) ||
          (('\u098f' <= yyC) && (yyC <= '\u0990')) ||
          (('\u0993' <= yyC) && (yyC <= '\u09a8')) ||
          (('\u09aa' <= yyC) && (yyC <= '\u09b0')) ||
          ('\u09b2' == yyC) ||
          (('\u09b6' <= yyC) && (yyC <= '\u09b9')) ||
          ('\u09bd' == yyC) ||
          ('\u09ce' == yyC) ||
          (('\u09dc' <= yyC) && (yyC <= '\u09dd')) ||
          (('\u09df' <= yyC) && (yyC <= '\u09e1')) ||
          (('\u09f0' <= yyC) && (yyC <= '\u09f1')) ||
          (('\u0a05' <= yyC) && (yyC <= '\u0a0a')) ||
          (('\u0a0f' <= yyC) && (yyC <= '\u0a10')) ||
          (('\u0a13' <= yyC) && (yyC <= '\u0a28')) ||
          (('\u0a2a' <= yyC) && (yyC <= '\u0a30')) ||
          (('\u0a32' <= yyC) && (yyC <= '\u0a33')) ||
          (('\u0a35' <= yyC) && (yyC <= '\u0a36')) ||
          (('\u0a38' <= yyC) && (yyC <= '\u0a39')) ||
          (('\u0a59' <= yyC) && (yyC <= '\u0a5c')) ||
          ('\u0a5e' == yyC) ||
          (('\u0a72' <= yyC) && (yyC <= '\u0a74')) ||
          (('\u0a85' <= yyC) && (yyC <= '\u0a8d')) ||
          (('\u0a8f' <= yyC) && (yyC <= '\u0a91')) ||
          (('\u0a93' <= yyC) && (yyC <= '\u0aa8')) ||
          (('\u0aaa' <= yyC) && (yyC <= '\u0ab0')) ||
          (('\u0ab2' <= yyC) && (yyC <= '\u0ab3')) ||
          (('\u0ab5' <= yyC) && (yyC <= '\u0ab9')) ||
          ('\u0abd' == yyC) ||
          ('\u0ad0' == yyC) ||
          (('\u0ae0' <= yyC) && (yyC <= '\u0ae1')) ||
          (('\u0b05' <= yyC) && (yyC <= '\u0b0c')) ||
          (('\u0b0f' <= yyC) && (yyC <= '\u0b10')) ||
          (('\u0b13' <= yyC) && (yyC <= '\u0b28')) ||
          (('\u0b2a' <= yyC) && (yyC <= '\u0b30')) ||
          (('\u0b32' <= yyC) && (yyC <= '\u0b33')) ||
          (('\u0b35' <= yyC) && (yyC <= '\u0b39')) ||
          ('\u0b3d' == yyC) ||
          (('\u0b5c' <= yyC) && (yyC <= '\u0b5d')) ||
          (('\u0b5f' <= yyC) && (yyC <= '\u0b61')) ||
          ('\u0b71' == yyC) ||
          ('\u0b83' == yyC) ||
          (('\u0b85' <= yyC) && (yyC <= '\u0b8a')) ||
          (('\u0b8e' <= yyC) && (yyC <= '\u0b90')) ||
          (('\u0b92' <= yyC) && (yyC <= '\u0b95')) ||
          (('\u0b99' <= yyC) && (yyC <= '\u0b9a')) ||
          ('\u0b9c' == yyC) ||
          (('\u0b9e' <= yyC) && (yyC <= '\u0b9f')) ||
          (('\u0ba3' <= yyC) && (yyC <= '\u0ba4')) ||
          (('\u0ba8' <= yyC) && (yyC <= '\u0baa')) ||
          (('\u0bae' <= yyC) && (yyC <= '\u0bb9')) ||
          (('\u0c05' <= yyC) && (yyC <= '\u0c0c')) ||
          (('\u0c0e' <= yyC) && (yyC <= '\u0c10')) ||
          (('\u0c12' <= yyC) && (yyC <= '\u0c28')) ||
          (('\u0c2a' <= yyC) && (yyC <= '\u0c33')) ||
          (('\u0c35' <= yyC) && (yyC <= '\u0c39')) ||
          (('\u0c60' <= yyC) && (yyC <= '\u0c61')) ||
          (('\u0c85' <= yyC) && (yyC <= '\u0c8c')) ||
          (('\u0c8e' <= yyC) && (yyC <= '\u0c90')) ||
          (('\u0c92' <= yyC) && (yyC <= '\u0ca8')) ||
          (('\u0caa' <= yyC) && (yyC <= '\u0cb3')) ||
          (('\u0cb5' <= yyC) && (yyC <= '\u0cb9')) ||
          ('\u0cbd' == yyC) ||
          ('\u0cde' == yyC) ||
          (('\u0ce0' <= yyC) && (yyC <= '\u0ce1')) ||
          (('\u0d05' <= yyC) && (yyC <= '\u0d0c')) ||
          (('\u0d0e' <= yyC) && (yyC <= '\u0d10')) ||
          (('\u0d12' <= yyC) && (yyC <= '\u0d28')) ||
          (('\u0d2a' <= yyC) && (yyC <= '\u0d39')) ||
          (('\u0d60' <= yyC) && (yyC <= '\u0d61')) ||
          (('\u0d85' <= yyC) && (yyC <= '\u0d96')) ||
          (('\u0d9a' <= yyC) && (yyC <= '\u0db1')) ||
          (('\u0db3' <= yyC) && (yyC <= '\u0dbb')) ||
          ('\u0dbd' == yyC) ||
          (('\u0dc0' <= yyC) && (yyC <= '\u0dc6')) ||
          (('\u0e01' <= yyC) && (yyC <= '\u0e30')) ||
          (('\u0e32' <= yyC) && (yyC <= '\u0e33')) ||
          (('\u0e40' <= yyC) && (yyC <= '\u0e46')) ||
          (('\u0e81' <= yyC) && (yyC <= '\u0e82')) ||
          ('\u0e84' == yyC) ||
          (('\u0e87' <= yyC) && (yyC <= '\u0e88')) ||
          ('\u0e8a' == yyC) ||
          ('\u0e8d' == yyC) ||
          (('\u0e94' <= yyC) && (yyC <= '\u0e97')) ||
          (('\u0e99' <= yyC) && (yyC <= '\u0e9f')) ||
          (('\u0ea1' <= yyC) && (yyC <= '\u0ea3')) ||
          ('\u0ea5' == yyC) ||
          ('\u0ea7' == yyC) ||
          (('\u0eaa' <= yyC) && (yyC <= '\u0eab')) ||
          (('\u0ead' <= yyC) && (yyC <= '\u0eb0')) ||
          (('\u0eb2' <= yyC) && (yyC <= '\u0eb3')) ||
          ('\u0ebd' == yyC) ||
          (('\u0ec0' <= yyC) && (yyC <= '\u0ec4')) ||
          ('\u0ec6' == yyC) ||
          (('\u0edc' <= yyC) && (yyC <= '\u0edd')) ||
          ('\u0f00' == yyC) ||
          (('\u0f40' <= yyC) && (yyC <= '\u0f47')) ||
          (('\u0f49' <= yyC) && (yyC <= '\u0f6a')) ||
          (('\u0f88' <= yyC) && (yyC <= '\u0f8b')) ||
          (('\u1000' <= yyC) && (yyC <= '\u1021')) ||
          (('\u1023' <= yyC) && (yyC <= '\u1027')) ||
          (('\u1029' <= yyC) && (yyC <= '\u102a')) ||
          (('\u1050' <= yyC) && (yyC <= '\u1055')) ||
          (('\u10a0' <= yyC) && (yyC <= '\u10c5')) ||
          (('\u10d0' <= yyC) && (yyC <= '\u10fa')) ||
          ('\u10fc' == yyC) ||
          (('\u1100' <= yyC) && (yyC <= '\u1159')) ||
          (('\u115f' <= yyC) && (yyC <= '\u11a2')) ||
          (('\u11a8' <= yyC) && (yyC <= '\u11f9')) ||
          (('\u1200' <= yyC) && (yyC <= '\u1248')) ||
          (('\u124a' <= yyC) && (yyC <= '\u124d')) ||
          (('\u1250' <= yyC) && (yyC <= '\u1256')) ||
          ('\u1258' == yyC) ||
          (('\u125a' <= yyC) && (yyC <= '\u125d')) ||
          (('\u1260' <= yyC) && (yyC <= '\u1288')) ||
          (('\u128a' <= yyC) && (yyC <= '\u128d')) ||
          (('\u1290' <= yyC) && (yyC <= '\u12b0')) ||
          (('\u12b2' <= yyC) && (yyC <= '\u12b5')) ||
          (('\u12b8' <= yyC) && (yyC <= '\u12be')) ||
          ('\u12c0' == yyC) ||
          (('\u12c2' <= yyC) && (yyC <= '\u12c5')) ||
          (('\u12c8' <= yyC) && (yyC <= '\u12d6')) ||
          (('\u12d8' <= yyC) && (yyC <= '\u1310')) ||
          (('\u1312' <= yyC) && (yyC <= '\u1315')) ||
          (('\u1318' <= yyC) && (yyC <= '\u135a')) ||
          (('\u1380' <= yyC) && (yyC <= '\u138f')) ||
          (('\u13a0' <= yyC) && (yyC <= '\u13f4')) ||
          (('\u1401' <= yyC) && (yyC <= '\u166c')) ||
          (('\u166f' <= yyC) && (yyC <= '\u1676')) ||
          (('\u1681' <= yyC) && (yyC <= '\u169a')) ||
          (('\u16a0' <= yyC) && (yyC <= '\u16ea')) ||
          (('\u16ee' <= yyC) && (yyC <= '\u16f0')) ||
          (('\u1700' <= yyC) && (yyC <= '\u170c')) ||
          (('\u170e' <= yyC) && (yyC <= '\u1711')) ||
          (('\u1720' <= yyC) && (yyC <= '\u1731')) ||
          (('\u1740' <= yyC) && (yyC <= '\u1751')) ||
          (('\u1760' <= yyC) && (yyC <= '\u176c')) ||
          (('\u176e' <= yyC) && (yyC <= '\u1770')) ||
          (('\u1780' <= yyC) && (yyC <= '\u17b3')) ||
          ('\u17d7' == yyC) ||
          ('\u17dc' == yyC) ||
          (('\u1820' <= yyC) && (yyC <= '\u1877')) ||
          (('\u1880' <= yyC) && (yyC <= '\u18a8')) ||
          (('\u1900' <= yyC) && (yyC <= '\u191c')) ||
          (('\u1950' <= yyC) && (yyC <= '\u196d')) ||
          (('\u1970' <= yyC) && (yyC <= '\u1974')) ||
          (('\u1980' <= yyC) && (yyC <= '\u19a9')) ||
          (('\u19c1' <= yyC) && (yyC <= '\u19c7')) ||
          (('\u1a00' <= yyC) && (yyC <= '\u1a16')) ||
          (('\u1b05' <= yyC) && (yyC <= '\u1b33')) ||
          (('\u1b45' <= yyC) && (yyC <= '\u1b4b')) ||
          (('\u1d00' <= yyC) && (yyC <= '\u1dbf')) ||
          (('\u1e00' <= yyC) && (yyC <= '\u1e9b')) ||
          (('\u1ea0' <= yyC) && (yyC <= '\u1ef9')) ||
          (('\u1f00' <= yyC) && (yyC <= '\u1f15')) ||
          (('\u1f18' <= yyC) && (yyC <= '\u1f1d')) ||
          (('\u1f20' <= yyC) && (yyC <= '\u1f45')) ||
          (('\u1f48' <= yyC) && (yyC <= '\u1f4d')) ||
          (('\u1f50' <= yyC) && (yyC <= '\u1f57')) ||
          ('\u1f59' == yyC) ||
          ('\u1f5b' == yyC) ||
          ('\u1f5d' == yyC) ||
          (('\u1f5f' <= yyC) && (yyC <= '\u1f7d')) ||
          (('\u1f80' <= yyC) && (yyC <= '\u1fb4')) ||
          (('\u1fb6' <= yyC) && (yyC <= '\u1fbc')) ||
          ('\u1fbe' == yyC) ||
          (('\u1fc2' <= yyC) && (yyC <= '\u1fc4')) ||
          (('\u1fc6' <= yyC) && (yyC <= '\u1fcc')) ||
          (('\u1fd0' <= yyC) && (yyC <= '\u1fd3')) ||
          (('\u1fd6' <= yyC) && (yyC <= '\u1fdb')) ||
          (('\u1fe0' <= yyC) && (yyC <= '\u1fec')) ||
          (('\u1ff2' <= yyC) && (yyC <= '\u1ff4')) ||
          (('\u1ff6' <= yyC) && (yyC <= '\u1ffc')) ||
          ('\u2071' == yyC) ||
          ('\u207f' == yyC) ||
          (('\u2090' <= yyC) && (yyC <= '\u2094')) ||
          ('\u2102' == yyC) ||
          ('\u2107' == yyC) ||
          (('\u210a' <= yyC) && (yyC <= '\u2113')) ||
          ('\u2115' == yyC) ||
          (('\u2119' <= yyC) && (yyC <= '\u211d')) ||
          ('\u2124' == yyC) ||
          ('\u2126' == yyC) ||
          ('\u2128' == yyC) ||
          (('\u212a' <= yyC) && (yyC <= '\u212d')) ||
          (('\u212f' <= yyC) && (yyC <= '\u2139')) ||
          (('\u213c' <= yyC) && (yyC <= '\u213f')) ||
          (('\u2145' <= yyC) && (yyC <= '\u2149')) ||
          ('\u214e' == yyC) ||
          (('\u2160' <= yyC) && (yyC <= '\u2184')) ||
          (('\u2c00' <= yyC) && (yyC <= '\u2c2e')) ||
          (('\u2c30' <= yyC) && (yyC <= '\u2c5e')) ||
          (('\u2c60' <= yyC) && (yyC <= '\u2c6c')) ||
          (('\u2c74' <= yyC) && (yyC <= '\u2c77')) ||
          (('\u2c80' <= yyC) && (yyC <= '\u2ce4')) ||
          (('\u2d00' <= yyC) && (yyC <= '\u2d25')) ||
          (('\u2d30' <= yyC) && (yyC <= '\u2d65')) ||
          ('\u2d6f' == yyC) ||
          (('\u2d80' <= yyC) && (yyC <= '\u2d96')) ||
          (('\u2da0' <= yyC) && (yyC <= '\u2da6')) ||
          (('\u2da8' <= yyC) && (yyC <= '\u2dae')) ||
          (('\u2db0' <= yyC) && (yyC <= '\u2db6')) ||
          (('\u2db8' <= yyC) && (yyC <= '\u2dbe')) ||
          (('\u2dc0' <= yyC) && (yyC <= '\u2dc6')) ||
          (('\u2dc8' <= yyC) && (yyC <= '\u2dce')) ||
          (('\u2dd0' <= yyC) && (yyC <= '\u2dd6')) ||
          (('\u2dd8' <= yyC) && (yyC <= '\u2dde')) ||
          (('\u3005' <= yyC) && (yyC <= '\u3007')) ||
          (('\u3021' <= yyC) && (yyC <= '\u3029')) ||
          (('\u3031' <= yyC) && (yyC <= '\u3035')) ||
          (('\u3038' <= yyC) && (yyC <= '\u303c')) ||
          (('\u3041' <= yyC) && (yyC <= '\u3096')) ||
          (('\u309d' <= yyC) && (yyC <= '\u309f')) ||
          (('\u30a1' <= yyC) && (yyC <= '\u30fa')) ||
          (('\u30fc' <= yyC) && (yyC <= '\u30ff')) ||
          (('\u3105' <= yyC) && (yyC <= '\u312c')) ||
          (('\u3131' <= yyC) && (yyC <= '\u318e')) ||
          (('\u31a0' <= yyC) && (yyC <= '\u31b7')) ||
          (('\u31f0' <= yyC) && (yyC <= '\u31ff')) ||
          (('\u3400' <= yyC) && (yyC <= '\u4db5')) ||
          (('\u4e00' <= yyC) && (yyC <= '\u9fbb')) ||
          (('\ua000' <= yyC) && (yyC <= '\ua48c')) ||
          (('\ua717' <= yyC) && (yyC <= '\ua71a')) ||
          (('\ua800' <= yyC) && (yyC <= '\ua801')) ||
          (('\ua803' <= yyC) && (yyC <= '\ua805')) ||
          (('\ua807' <= yyC) && (yyC <= '\ua80a')) ||
          (('\ua80c' <= yyC) && (yyC <= '\ua822')) ||
          (('\ua840' <= yyC) && (yyC <= '\ua873')) ||
          (('\uac00' <= yyC) && (yyC <= '\ud7a3')) ||
          (('\uf900' <= yyC) && (yyC <= '\ufa2d')) ||
          (('\ufa30' <= yyC) && (yyC <= '\ufa6a')) ||
          (('\ufa70' <= yyC) && (yyC <= '\ufad9')) ||
          (('\ufb00' <= yyC) && (yyC <= '\ufb06')) ||
          (('\ufb13' <= yyC) && (yyC <= '\ufb17')) ||
          ('\ufb1d' == yyC) ||
          (('\ufb1f' <= yyC) && (yyC <= '\ufb28')) ||
          (('\ufb2a' <= yyC) && (yyC <= '\ufb36')) ||
          (('\ufb38' <= yyC) && (yyC <= '\ufb3c')) ||
          ('\ufb3e' == yyC) ||
          (('\ufb40' <= yyC) && (yyC <= '\ufb41')) ||
          (('\ufb43' <= yyC) && (yyC <= '\ufb44')) ||
          (('\ufb46' <= yyC) && (yyC <= '\ufbb1')) ||
          (('\ufbd3' <= yyC) && (yyC <= '\ufd3d')) ||
          (('\ufd50' <= yyC) && (yyC <= '\ufd8f')) ||
          (('\ufd92' <= yyC) && (yyC <= '\ufdc7')) ||
          (('\ufdf0' <= yyC) && (yyC <= '\ufdfb')) ||
          (('\ufe70' <= yyC) && (yyC <= '\ufe74')) ||
          (('\ufe76' <= yyC) && (yyC <= '\ufefc')) ||
          (('\uff21' <= yyC) && (yyC <= '\uff3a')) ||
          (('\uff41' <= yyC) && (yyC <= '\uff5a')) ||
          (('\uff66' <= yyC) && (yyC <= '\uffbe')) ||
          (('\uffc2' <= yyC) && (yyC <= '\uffc7')) ||
          (('\uffca' <= yyC) && (yyC <= '\uffcf')) ||
          (('\uffd2' <= yyC) && (yyC <= '\uffd7')) ||
          (('\uffda' <= yyC) && (yyC <= '\uffdc'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud800':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc0b')) ||
                (('\udc0d' <= yyC) && (yyC <= '\udc26')) ||
                (('\udc28' <= yyC) && (yyC <= '\udc3a')) ||
                (('\udc3c' <= yyC) && (yyC <= '\udc3d')) ||
                (('\udc3f' <= yyC) && (yyC <= '\udc4d')) ||
                (('\udc50' <= yyC) && (yyC <= '\udc5d')) ||
                (('\udc80' <= yyC) && (yyC <= '\udcfa')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd74')) ||
                (('\udf00' <= yyC) && (yyC <= '\udf1e')) ||
                (('\udf30' <= yyC) && (yyC <= '\udf4a')) ||
                (('\udf80' <= yyC) && (yyC <= '\udf9d')) ||
                (('\udfa0' <= yyC) && (yyC <= '\udfc3')) ||
                (('\udfc8' <= yyC) && (yyC <= '\udfcf')) ||
                (('\udfd1' <= yyC) && (yyC <= '\udfd5'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc9d')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc05')) ||
                ('\udc08' == yyC) ||
                (('\udc0a' <= yyC) && (yyC <= '\udc35')) ||
                (('\udc37' <= yyC) && (yyC <= '\udc38')) ||
                ('\udc3c' == yyC) ||
                ('\udc3f' == yyC) ||
                (('\udd00' <= yyC) && (yyC <= '\udd15')) ||
                ('\ude00' == yyC) ||
                (('\ude10' <= yyC) && (yyC <= '\ude13')) ||
                (('\ude15' <= yyC) && (yyC <= '\ude17')) ||
                (('\ude19' <= yyC) && (yyC <= '\ude33'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud808':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udf6e')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud809':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc62')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc54')) ||
                (('\udc56' <= yyC) && (yyC <= '\udc9c')) ||
                (('\udc9e' <= yyC) && (yyC <= '\udc9f')) ||
                ('\udca2' == yyC) ||
                (('\udca5' <= yyC) && (yyC <= '\udca6')) ||
                (('\udca9' <= yyC) && (yyC <= '\udcac')) ||
                (('\udcae' <= yyC) && (yyC <= '\udcb9')) ||
                ('\udcbb' == yyC) ||
                (('\udcbd' <= yyC) && (yyC <= '\udcc3')) ||
                (('\udcc5' <= yyC) && (yyC <= '\udd05')) ||
                (('\udd07' <= yyC) && (yyC <= '\udd0a')) ||
                (('\udd0d' <= yyC) && (yyC <= '\udd14')) ||
                (('\udd16' <= yyC) && (yyC <= '\udd1c')) ||
                (('\udd1e' <= yyC) && (yyC <= '\udd39')) ||
                (('\udd3b' <= yyC) && (yyC <= '\udd3e')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd44')) ||
                ('\udd46' == yyC) ||
                (('\udd4a' <= yyC) && (yyC <= '\udd50')) ||
                (('\udd52' <= yyC) && (yyC <= '\udea5')) ||
                (('\udea8' <= yyC) && (yyC <= '\udec0')) ||
                (('\udec2' <= yyC) && (yyC <= '\udeda')) ||
                (('\udedc' <= yyC) && (yyC <= '\udefa')) ||
                (('\udefc' <= yyC) && (yyC <= '\udf14')) ||
                (('\udf16' <= yyC) && (yyC <= '\udf34')) ||
                (('\udf36' <= yyC) && (yyC <= '\udf4e')) ||
                (('\udf50' <= yyC) && (yyC <= '\udf6e')) ||
                (('\udf70' <= yyC) && (yyC <= '\udf88')) ||
                (('\udf8a' <= yyC) && (yyC <= '\udfa8')) ||
                (('\udfaa' <= yyC) && (yyC <= '\udfc2')) ||
                (('\udfc4' <= yyC) && (yyC <= '\udfcb'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud840':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\uded6')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud87e':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\ude1d')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '$':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '_':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\\':
        {
          yyResult = pUnicodeEscapeSequence(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('\u0300' <= yyC) && (yyC <= '\u036f')) ||
          (('\u0483' <= yyC) && (yyC <= '\u0486')) ||
          (('\u0591' <= yyC) && (yyC <= '\u05bd')) ||
          ('\u05bf' == yyC) ||
          (('\u05c1' <= yyC) && (yyC <= '\u05c2')) ||
          (('\u05c4' <= yyC) && (yyC <= '\u05c5')) ||
          ('\u05c7' == yyC) ||
          (('\u0610' <= yyC) && (yyC <= '\u0615')) ||
          (('\u064b' <= yyC) && (yyC <= '\u065e')) ||
          ('\u0670' == yyC) ||
          (('\u06d6' <= yyC) && (yyC <= '\u06dc')) ||
          (('\u06df' <= yyC) && (yyC <= '\u06e4')) ||
          (('\u06e7' <= yyC) && (yyC <= '\u06e8')) ||
          (('\u06ea' <= yyC) && (yyC <= '\u06ed')) ||
          ('\u0711' == yyC) ||
          (('\u0730' <= yyC) && (yyC <= '\u074a')) ||
          (('\u07a6' <= yyC) && (yyC <= '\u07b0')) ||
          (('\u07eb' <= yyC) && (yyC <= '\u07f3')) ||
          (('\u0901' <= yyC) && (yyC <= '\u0903')) ||
          ('\u093c' == yyC) ||
          (('\u093e' <= yyC) && (yyC <= '\u094d')) ||
          (('\u0951' <= yyC) && (yyC <= '\u0954')) ||
          (('\u0962' <= yyC) && (yyC <= '\u0963')) ||
          (('\u0981' <= yyC) && (yyC <= '\u0983')) ||
          ('\u09bc' == yyC) ||
          (('\u09be' <= yyC) && (yyC <= '\u09c4')) ||
          (('\u09c7' <= yyC) && (yyC <= '\u09c8')) ||
          (('\u09cb' <= yyC) && (yyC <= '\u09cd')) ||
          ('\u09d7' == yyC) ||
          (('\u09e2' <= yyC) && (yyC <= '\u09e3')) ||
          (('\u0a01' <= yyC) && (yyC <= '\u0a03')) ||
          ('\u0a3c' == yyC) ||
          (('\u0a3e' <= yyC) && (yyC <= '\u0a42')) ||
          (('\u0a47' <= yyC) && (yyC <= '\u0a48')) ||
          (('\u0a4b' <= yyC) && (yyC <= '\u0a4d')) ||
          (('\u0a70' <= yyC) && (yyC <= '\u0a71')) ||
          (('\u0a81' <= yyC) && (yyC <= '\u0a83')) ||
          ('\u0abc' == yyC) ||
          (('\u0abe' <= yyC) && (yyC <= '\u0ac5')) ||
          (('\u0ac7' <= yyC) && (yyC <= '\u0ac9')) ||
          (('\u0acb' <= yyC) && (yyC <= '\u0acd')) ||
          (('\u0ae2' <= yyC) && (yyC <= '\u0ae3')) ||
          (('\u0b01' <= yyC) && (yyC <= '\u0b03')) ||
          ('\u0b3c' == yyC) ||
          (('\u0b3e' <= yyC) && (yyC <= '\u0b43')) ||
          (('\u0b47' <= yyC) && (yyC <= '\u0b48')) ||
          (('\u0b4b' <= yyC) && (yyC <= '\u0b4d')) ||
          (('\u0b56' <= yyC) && (yyC <= '\u0b57')) ||
          ('\u0b82' == yyC) ||
          (('\u0bbe' <= yyC) && (yyC <= '\u0bc2')) ||
          (('\u0bc6' <= yyC) && (yyC <= '\u0bc8')) ||
          (('\u0bca' <= yyC) && (yyC <= '\u0bcd')) ||
          ('\u0bd7' == yyC) ||
          (('\u0c01' <= yyC) && (yyC <= '\u0c03')) ||
          (('\u0c3e' <= yyC) && (yyC <= '\u0c44')) ||
          (('\u0c46' <= yyC) && (yyC <= '\u0c48')) ||
          (('\u0c4a' <= yyC) && (yyC <= '\u0c4d')) ||
          (('\u0c55' <= yyC) && (yyC <= '\u0c56')) ||
          (('\u0c82' <= yyC) && (yyC <= '\u0c83')) ||
          ('\u0cbc' == yyC) ||
          (('\u0cbe' <= yyC) && (yyC <= '\u0cc4')) ||
          (('\u0cc6' <= yyC) && (yyC <= '\u0cc8')) ||
          (('\u0cca' <= yyC) && (yyC <= '\u0ccd')) ||
          (('\u0cd5' <= yyC) && (yyC <= '\u0cd6')) ||
          (('\u0ce2' <= yyC) && (yyC <= '\u0ce3')) ||
          (('\u0d02' <= yyC) && (yyC <= '\u0d03')) ||
          (('\u0d3e' <= yyC) && (yyC <= '\u0d43')) ||
          (('\u0d46' <= yyC) && (yyC <= '\u0d48')) ||
          (('\u0d4a' <= yyC) && (yyC <= '\u0d4d')) ||
          ('\u0d57' == yyC) ||
          (('\u0d82' <= yyC) && (yyC <= '\u0d83')) ||
          ('\u0dca' == yyC) ||
          (('\u0dcf' <= yyC) && (yyC <= '\u0dd4')) ||
          ('\u0dd6' == yyC) ||
          (('\u0dd8' <= yyC) && (yyC <= '\u0ddf')) ||
          (('\u0df2' <= yyC) && (yyC <= '\u0df3')) ||
          ('\u0e31' == yyC) ||
          (('\u0e34' <= yyC) && (yyC <= '\u0e3a')) ||
          (('\u0e47' <= yyC) && (yyC <= '\u0e4e')) ||
          ('\u0eb1' == yyC) ||
          (('\u0eb4' <= yyC) && (yyC <= '\u0eb9')) ||
          (('\u0ebb' <= yyC) && (yyC <= '\u0ebc')) ||
          (('\u0ec8' <= yyC) && (yyC <= '\u0ecd')) ||
          (('\u0f18' <= yyC) && (yyC <= '\u0f19')) ||
          ('\u0f35' == yyC) ||
          ('\u0f37' == yyC) ||
          ('\u0f39' == yyC) ||
          (('\u0f3e' <= yyC) && (yyC <= '\u0f3f')) ||
          (('\u0f71' <= yyC) && (yyC <= '\u0f84')) ||
          (('\u0f86' <= yyC) && (yyC <= '\u0f87')) ||
          (('\u0f90' <= yyC) && (yyC <= '\u0f97')) ||
          (('\u0f99' <= yyC) && (yyC <= '\u0fbc')) ||
          ('\u0fc6' == yyC) ||
          (('\u102c' <= yyC) && (yyC <= '\u1032')) ||
          (('\u1036' <= yyC) && (yyC <= '\u1039')) ||
          (('\u1056' <= yyC) && (yyC <= '\u1059')) ||
          ('\u135f' == yyC) ||
          (('\u1712' <= yyC) && (yyC <= '\u1714')) ||
          (('\u1732' <= yyC) && (yyC <= '\u1734')) ||
          (('\u1752' <= yyC) && (yyC <= '\u1753')) ||
          (('\u1772' <= yyC) && (yyC <= '\u1773')) ||
          (('\u17b6' <= yyC) && (yyC <= '\u17d3')) ||
          ('\u17dd' == yyC) ||
          (('\u180b' <= yyC) && (yyC <= '\u180d')) ||
          ('\u18a9' == yyC) ||
          (('\u1920' <= yyC) && (yyC <= '\u192b')) ||
          (('\u1930' <= yyC) && (yyC <= '\u193b')) ||
          (('\u19b0' <= yyC) && (yyC <= '\u19c0')) ||
          (('\u19c8' <= yyC) && (yyC <= '\u19c9')) ||
          (('\u1a17' <= yyC) && (yyC <= '\u1a1b')) ||
          (('\u1b00' <= yyC) && (yyC <= '\u1b04')) ||
          (('\u1b34' <= yyC) && (yyC <= '\u1b44')) ||
          (('\u1b6b' <= yyC) && (yyC <= '\u1b73')) ||
          (('\u1dc0' <= yyC) && (yyC <= '\u1dca')) ||
          (('\u1dfe' <= yyC) && (yyC <= '\u1dff')) ||
          (('\u20d0' <= yyC) && (yyC <= '\u20dc')) ||
          ('\u20e1' == yyC) ||
          (('\u20e5' <= yyC) && (yyC <= '\u20ef')) ||
          (('\u302a' <= yyC) && (yyC <= '\u302f')) ||
          (('\u3099' <= yyC) && (yyC <= '\u309a')) ||
          ('\ua802' == yyC) ||
          ('\ua806' == yyC) ||
          ('\ua80b' == yyC) ||
          (('\ua823' <= yyC) && (yyC <= '\ua827')) ||
          ('\ufb1e' == yyC) ||
          (('\ufe00' <= yyC) && (yyC <= '\ufe0f')) ||
          (('\ufe20' <= yyC) && (yyC <= '\ufe23'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '\ude01':
            case '\ude02':
            case '\ude03':
            case '\ude05':
            case '\ude06':
            case '\ude0c':
            case '\ude0d':
            case '\ude0e':
            case '\ude0f':
            case '\ude38':
            case '\ude39':
            case '\ude3a':
            case '\ude3f':
              {
                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '\ud834':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udd65' <= yyC) && (yyC <= '\udd69')) ||
                (('\udd6d' <= yyC) && (yyC <= '\udd72')) ||
                (('\udd7b' <= yyC) && (yyC <= '\udd82')) ||
                (('\udd85' <= yyC) && (yyC <= '\udd8b')) ||
                (('\uddaa' <= yyC) && (yyC <= '\uddad')) ||
                (('\ude42' <= yyC) && (yyC <= '\ude44'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\udb40':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udd00' <= yyC) && (yyC <= '\uddef')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 5.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('0' <= yyC) && (yyC <= '9')) ||
          (('\u0660' <= yyC) && (yyC <= '\u0669')) ||
          (('\u06f0' <= yyC) && (yyC <= '\u06f9')) ||
          (('\u07c0' <= yyC) && (yyC <= '\u07c9')) ||
          (('\u0966' <= yyC) && (yyC <= '\u096f')) ||
          (('\u09e6' <= yyC) && (yyC <= '\u09ef')) ||
          (('\u0a66' <= yyC) && (yyC <= '\u0a6f')) ||
          (('\u0ae6' <= yyC) && (yyC <= '\u0aef')) ||
          (('\u0b66' <= yyC) && (yyC <= '\u0b6f')) ||
          (('\u0be6' <= yyC) && (yyC <= '\u0bef')) ||
          (('\u0c66' <= yyC) && (yyC <= '\u0c6f')) ||
          (('\u0ce6' <= yyC) && (yyC <= '\u0cef')) ||
          (('\u0d66' <= yyC) && (yyC <= '\u0d6f')) ||
          (('\u0e50' <= yyC) && (yyC <= '\u0e59')) ||
          (('\u0ed0' <= yyC) && (yyC <= '\u0ed9')) ||
          (('\u0f20' <= yyC) && (yyC <= '\u0f29')) ||
          (('\u1040' <= yyC) && (yyC <= '\u1049')) ||
          (('\u17e0' <= yyC) && (yyC <= '\u17e9')) ||
          (('\u1810' <= yyC) && (yyC <= '\u1819')) ||
          (('\u1946' <= yyC) && (yyC <= '\u194f')) ||
          (('\u19d0' <= yyC) && (yyC <= '\u19d9')) ||
          (('\u1b50' <= yyC) && (yyC <= '\u1b59')) ||
          (('\uff10' <= yyC) && (yyC <= '\uff19'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 6.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '\udca0':
            case '\udca1':
            case '\udca2':
            case '\udca3':
            case '\udca4':
            case '\udca5':
            case '\udca6':
            case '\udca7':
            case '\udca8':
            case '\udca9':
              {
                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udfce' <= yyC) && (yyC <= '\udfff')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '_':
      case '\u203f':
      case '\u2040':
      case '\u2054':
      case '\ufe33':
      case '\ufe34':
      case '\ufe4d':
      case '\ufe4e':
      case '\ufe4f':
      case '\uff3f':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\u200c':
      case '\u200d':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("idrest expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.UnicodeEscapeSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnicodeEscapeSequence(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('u' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pIdentifier$HexDigit(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdentifier$HexDigit(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pIdentifier$HexDigit(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIdentifier$HexDigit(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = null;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("unicode escape sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.HexDigit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifier$HexDigit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("hex digit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared24.
   * This nonterminal represents the duplicate productions Identifier.IdText 
   * and Identifier.IdTextName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared24(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared14(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = difference(yyStart, yyResult.index);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared31.
   * This nonterminal represents the duplicate productions Identifier.Id 
   * and Identifier.IdName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared31(final int yyStart) throws IOException {
    Result     yyResult;
    Id         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared24(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      String id = NodeUtil.convertUnicode(a1);
      yyValue = new Id(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)), id);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.semicolon.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psemicolon(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (';' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("semicolon expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.colon.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcolon(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("colon expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.comma.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcomma(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("comma expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.star.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pstar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("star expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.underscore.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result punderscore(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("underscore expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.openparen.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popenparen(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("openparen expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closeparen.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcloseparen(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (')' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("closeparen expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.opencurly.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popencurly(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("opencurly expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closecurly.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pclosecurly(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('}' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("closecurly expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.opensquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popensquare(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("opensquare expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closesquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pclosesquare(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (']' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("closesquare expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.dot.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdot(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("dot expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.equals.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pequals(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if ('=' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), "=");

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("equals expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("equals expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.plus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pplus(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyPredResult = pplus$$Choice1(yyIndex);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), "+");

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("plus expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("plus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.plus$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pplus$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '+':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '=':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("plus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.minus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pminus(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyPredResult = pminus$$Choice1(yyIndex);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), "-");

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("minus expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("minus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.minus$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pminus$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '-':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '=':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("minus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.doubleplus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdoubleplus(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('+' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), "++");

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("doubleplus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.doubleminus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdoubleminus(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyC = character(yyIndex);
        if ('>' == yyC) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), "--");

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("doubleminus expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("doubleminus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.tilde.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptilde(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('~' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), "~");

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("tilde expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.bang.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbang(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('!' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), "!");

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("bang expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.and.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pand(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('&' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyPredResult = pand$$Choice1(yyIndex);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), "&");

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("and expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("and expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.and$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pand$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '&':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '=':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("and expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.ands.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pands(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('&' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('&' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), "&&");

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("ands expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.bar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyPredResult = pbar$$Choice1(yyIndex);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), "|");

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("bar expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("bar expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.bar$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbar$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '|':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '=':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("bar expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.bars.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbars(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('|' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), "||");

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bars expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.caret.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcaret(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('^' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if ('=' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), "^");

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("caret expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("caret expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.question.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pquestion(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('?' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if ('=' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), "?");

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("question expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("question expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.AssignmentOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssignmentOp(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAssignmentOp$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pequals(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), a1+"=");

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.saf.parser.SOL.AssignmentOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssignmentOp$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "*";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "/";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('%' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "%";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "+";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 5.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "-";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 6.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('<' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "<<";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 7.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = ">>";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 8.

    yyC = character(yyStart);
    if ('&' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "&";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 9.

    yyC = character(yyStart);
    if ('^' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "^";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 10.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "|";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("assignment op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.EqualityOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityOp(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEqualityOp$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.saf.parser.SOL.EqualityOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityOp$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "==";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('!' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "!=";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("equality op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.RelationalOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalOp(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRelationalOp$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.saf.parser.SOL.RelationalOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalOp$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "<=";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = ">=";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "<";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = ">";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("relational op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.ShiftOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pShiftOp(final int yyStart) throws IOException {
    int        yyC;
    Result     yyResult;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pShiftOp$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyPredMatched = false;

      yyC = character(yyResult.index);
      if ('=' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), a1);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("shift op expected", yyStart);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.ShiftOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pShiftOp$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('<' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "<<";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = ">>";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("shift op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.AdditiveOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditiveOp(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAdditiveOp$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.saf.parser.SOL.AdditiveOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditiveOp$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pplus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pminus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.MultiplicativeOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicativeOp(final int yyStart) throws IOException {
    int        yyC;
    Result     yyResult;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMultiplicativeOp$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyPredMatched = false;

      yyC = character(yyResult.index);
      if ('=' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), a1);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("multiplicative op expected", yyStart);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.saf.parser.SOL.MultiplicativeOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicativeOp$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "**";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "*";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "/";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('%' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "%";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("multiplicative op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.EndOfFile.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEndOfFile(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyBase = yyOption1;
    yyC    = character(yyBase);
    if ('\u001a' == yyC) {
      yyIndex = yyOption1 + 1;

      yyOption1  = yyIndex;
    } else {
      yyError = yyError.select("'\\u001a' expected", yyBase);
    }

    yyResult = pw(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyPredMatched = false;

      yyC = character(yyResult.index);
      if (-1 != yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("end of file expected", yyStart);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.MultiLineCommentChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineCommentChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyPredIndex;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyPredIndex = yyStart + 1;

      yyC = character(yyPredIndex);
      if ('/' == yyC) {

        yyPredMatched = true;
      }
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        char a1 = (char)yyC;

        yyValue = a1+"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("multi line comment char expected", yyStart);
    }

    // Done.
    yyError = yyError.select("multi line comment char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.MultiLineCommentWLB.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineCommentWLB(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    int          yyBase;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    String       yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pMultiLineCommentCharNoLB(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            String v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for a1s.
          Pair<String> a1s = yyRepValue1.reverse();

          yyResult = p$$Shared15(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = Pair.empty();
            while (true) {

              yyResult = pMultiLineCommentCharWLB(yyRepetition1);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {
                String v$el$2 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<String>(v$el$2, yyRepValue1);
                continue;
              }
              break;
            }
            { // Start scope for a3s.
              Pair<String> a3s = yyRepValue1.reverse();

              yyBase = yyRepetition1;
              yyC    = character(yyBase);
              if ('*' == yyC) {
                yyIndex = yyRepetition1 + 1;

                yyC = character(yyIndex);
                if ('/' == yyC) {
                  yyIndex = yyIndex + 1;

                  StringBuilder buf = new StringBuilder();
                  buf.append("/*");
                  for (String s : a1s.list()) buf.append(s);
                  buf.append(a2);
                  for (String s : a3s.list()) buf.append(s);
                  buf.append("*/");
                  yyValue = buf.toString();
                  handleComment(createSpan(yyStart,yyCount+1), yyValue);

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("'*/' expected", yyBase);
                }
              } else {
                yyError = yyError.select("'*/' expected", yyBase);
              }
            } // End scope for a3s.
          }
        } // End scope for a1s.
      }
    }

    // Done.
    yyError = yyError.select("multi line comment w l b expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.MultiLineCommentCharWLB.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineCommentCharWLB(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    int        yyPredIndex;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyPredIndex = yyStart + 1;

      yyC = character(yyPredIndex);
      if ('/' == yyC) {

        yyPredMatched = true;
      }
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("multi line comment char w l b expected", yyStart);
    }

    // Done.
    yyError = yyError.select("multi line comment char w l b expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.MultiLineCommentNoLB.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineCommentNoLB(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    int          yyBase;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    String       yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pMultiLineCommentCharNoLB(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            String v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for a1s.
          Pair<String> a1s = yyRepValue1.reverse();

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if ('*' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyC = character(yyIndex);
            if ('/' == yyC) {
              yyIndex = yyIndex + 1;

              StringBuilder buf = new StringBuilder();
              buf.append("/*");
              for (String s : a1s.list()) buf.append(s);
              buf.append("*/");
              yyValue = buf.toString();
              handleComment(createSpan(yyStart,yyCount+1), yyValue);

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("'*/' expected", yyBase);
            }
          } else {
            yyError = yyError.select("'*/' expected", yyBase);
          }
        } // End scope for a1s.
      }
    }

    // Done.
    yyError = yyError.select("multi line comment no l b expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.MultiLineCommentCharNoLB.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineCommentCharNoLB(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pMultiLineCommentCharNoLB$$Choice1(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        char a1 = (char)yyC;

        yyValue = a1+"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("multi line comment char no l b expected", yyStart);
    }

    // Done.
    yyError = yyError.select("multi line comment char no l b expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.saf.parser.SOL.MultiLineCommentCharNoLB$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineCommentCharNoLB$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyResult = p$$Shared15(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("multi line comment char no l b expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.saf.parser.SOL.SingleLineComment$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSingleLineComment$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "//";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('!' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('-' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('-' == yyC) {
            yyIndex = yyIndex + 1;
            yyValue = "<!--";

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("single line comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.PragmaVersionChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPragmaVersionChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (';' == yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        char a1 = (char)yyC;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("pragma version char expected", yyStart);
    }

    // Done.
    yyError = yyError.select("pragma version char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.SingleLineCommentChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSingleLineCommentChar(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = p$$Shared15(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        char a1 = (char)yyC;

        yyValue = a1+"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("single line comment char expected", yyStart);
    }

    // Done.
    yyError = yyError.select("single line comment char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.$$Shared15.
   * This nonterminal represents the duplicate productions 
   * Spacing.LineTerminatorChar and Spacing.LineTerminatorNoMC.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared15(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared15$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = ""+a1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.saf.parser.SOL.$$Shared15$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared15$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\n' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\u2028' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('\u2029' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.LineTerminatorSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLineTerminatorSequence(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLineTerminatorSequence$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = ""+a1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      final int yyChoice1 = yyIndex;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if ('\n' == yyC) {
        yyIndex = yyChoice1 + 1;
        char a2 = (char)yyC;

        yyValue = ""+a1+a2;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }

      // Nested alternative 2.

      yyPredMatched = false;

      yyC = character(yyChoice1);
      if ('\n' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = ""+a1;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      } else {
        yyError = yyError.select("line terminator sequence expected", yyStart);
      }
    }

    // Alternative 3.

    yyResult = pMultiLineCommentWLB(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("line terminator sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.saf.parser.SOL.LineTerminatorSequence$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLineTerminatorSequence$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\n' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\u2028' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\u2029' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("line terminator sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpace(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    Result       yyPredResult;
    boolean      yyPredMatched;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    Void         yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\t' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\u000b':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\u3000':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\f' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (' ' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 5.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\u00a0':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\ufeff':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '-':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('-' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('>' == yyC) {

                  yyPredMatched = false;

                  yyPredResult = pSpace$$Choice1(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("space expected", yyStart);
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 6.

    yyResult = pSingleLineComment$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pSingleLineCommentChar(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          String v$el$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<String>(v$el$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<String> a2s = yyRepValue1.reverse();

        StringBuilder buf = new StringBuilder();
        buf.append(a1);
        for (String s : a2s.list()) buf.append(s);
        handleComment(createSpan(yyStart,yyCount+1), buf.toString());

        yyValue = null;

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Alternative 7.

    yyResult = pMultiLineCommentNoLB(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.saf.parser.SOL.Space$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpace$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z')) ||
          ('\u00aa' == yyC) ||
          ('\u00b5' == yyC) ||
          ('\u00ba' == yyC) ||
          (('\u00c0' <= yyC) && (yyC <= '\u00d6')) ||
          (('\u00d8' <= yyC) && (yyC <= '\u00f6')) ||
          (('\u00f8' <= yyC) && (yyC <= '\u02c1')) ||
          (('\u02c6' <= yyC) && (yyC <= '\u02d1')) ||
          (('\u02e0' <= yyC) && (yyC <= '\u02e4')) ||
          ('\u02ee' == yyC) ||
          (('\u037a' <= yyC) && (yyC <= '\u037d')) ||
          ('\u0386' == yyC) ||
          (('\u0388' <= yyC) && (yyC <= '\u038a')) ||
          ('\u038c' == yyC) ||
          (('\u038e' <= yyC) && (yyC <= '\u03a1')) ||
          (('\u03a3' <= yyC) && (yyC <= '\u03ce')) ||
          (('\u03d0' <= yyC) && (yyC <= '\u03f5')) ||
          (('\u03f7' <= yyC) && (yyC <= '\u0481')) ||
          (('\u048a' <= yyC) && (yyC <= '\u0513')) ||
          (('\u0531' <= yyC) && (yyC <= '\u0556')) ||
          ('\u0559' == yyC) ||
          (('\u0561' <= yyC) && (yyC <= '\u0587')) ||
          (('\u05d0' <= yyC) && (yyC <= '\u05ea')) ||
          (('\u05f0' <= yyC) && (yyC <= '\u05f2')) ||
          (('\u0621' <= yyC) && (yyC <= '\u063a')) ||
          (('\u0640' <= yyC) && (yyC <= '\u064a')) ||
          (('\u066e' <= yyC) && (yyC <= '\u066f')) ||
          (('\u0671' <= yyC) && (yyC <= '\u06d3')) ||
          ('\u06d5' == yyC) ||
          (('\u06e5' <= yyC) && (yyC <= '\u06e6')) ||
          (('\u06ee' <= yyC) && (yyC <= '\u06ef')) ||
          (('\u06fa' <= yyC) && (yyC <= '\u06fc')) ||
          ('\u06ff' == yyC) ||
          ('\u0710' == yyC) ||
          (('\u0712' <= yyC) && (yyC <= '\u072f')) ||
          (('\u074d' <= yyC) && (yyC <= '\u076d')) ||
          (('\u0780' <= yyC) && (yyC <= '\u07a5')) ||
          ('\u07b1' == yyC) ||
          (('\u07ca' <= yyC) && (yyC <= '\u07ea')) ||
          (('\u07f4' <= yyC) && (yyC <= '\u07f5')) ||
          ('\u07fa' == yyC) ||
          (('\u0904' <= yyC) && (yyC <= '\u0939')) ||
          ('\u093d' == yyC) ||
          ('\u0950' == yyC) ||
          (('\u0958' <= yyC) && (yyC <= '\u0961')) ||
          (('\u097b' <= yyC) && (yyC <= '\u097f')) ||
          (('\u0985' <= yyC) && (yyC <= '\u098c')) ||
          (('\u098f' <= yyC) && (yyC <= '\u0990')) ||
          (('\u0993' <= yyC) && (yyC <= '\u09a8')) ||
          (('\u09aa' <= yyC) && (yyC <= '\u09b0')) ||
          ('\u09b2' == yyC) ||
          (('\u09b6' <= yyC) && (yyC <= '\u09b9')) ||
          ('\u09bd' == yyC) ||
          ('\u09ce' == yyC) ||
          (('\u09dc' <= yyC) && (yyC <= '\u09dd')) ||
          (('\u09df' <= yyC) && (yyC <= '\u09e1')) ||
          (('\u09f0' <= yyC) && (yyC <= '\u09f1')) ||
          (('\u0a05' <= yyC) && (yyC <= '\u0a0a')) ||
          (('\u0a0f' <= yyC) && (yyC <= '\u0a10')) ||
          (('\u0a13' <= yyC) && (yyC <= '\u0a28')) ||
          (('\u0a2a' <= yyC) && (yyC <= '\u0a30')) ||
          (('\u0a32' <= yyC) && (yyC <= '\u0a33')) ||
          (('\u0a35' <= yyC) && (yyC <= '\u0a36')) ||
          (('\u0a38' <= yyC) && (yyC <= '\u0a39')) ||
          (('\u0a59' <= yyC) && (yyC <= '\u0a5c')) ||
          ('\u0a5e' == yyC) ||
          (('\u0a72' <= yyC) && (yyC <= '\u0a74')) ||
          (('\u0a85' <= yyC) && (yyC <= '\u0a8d')) ||
          (('\u0a8f' <= yyC) && (yyC <= '\u0a91')) ||
          (('\u0a93' <= yyC) && (yyC <= '\u0aa8')) ||
          (('\u0aaa' <= yyC) && (yyC <= '\u0ab0')) ||
          (('\u0ab2' <= yyC) && (yyC <= '\u0ab3')) ||
          (('\u0ab5' <= yyC) && (yyC <= '\u0ab9')) ||
          ('\u0abd' == yyC) ||
          ('\u0ad0' == yyC) ||
          (('\u0ae0' <= yyC) && (yyC <= '\u0ae1')) ||
          (('\u0b05' <= yyC) && (yyC <= '\u0b0c')) ||
          (('\u0b0f' <= yyC) && (yyC <= '\u0b10')) ||
          (('\u0b13' <= yyC) && (yyC <= '\u0b28')) ||
          (('\u0b2a' <= yyC) && (yyC <= '\u0b30')) ||
          (('\u0b32' <= yyC) && (yyC <= '\u0b33')) ||
          (('\u0b35' <= yyC) && (yyC <= '\u0b39')) ||
          ('\u0b3d' == yyC) ||
          (('\u0b5c' <= yyC) && (yyC <= '\u0b5d')) ||
          (('\u0b5f' <= yyC) && (yyC <= '\u0b61')) ||
          ('\u0b71' == yyC) ||
          ('\u0b83' == yyC) ||
          (('\u0b85' <= yyC) && (yyC <= '\u0b8a')) ||
          (('\u0b8e' <= yyC) && (yyC <= '\u0b90')) ||
          (('\u0b92' <= yyC) && (yyC <= '\u0b95')) ||
          (('\u0b99' <= yyC) && (yyC <= '\u0b9a')) ||
          ('\u0b9c' == yyC) ||
          (('\u0b9e' <= yyC) && (yyC <= '\u0b9f')) ||
          (('\u0ba3' <= yyC) && (yyC <= '\u0ba4')) ||
          (('\u0ba8' <= yyC) && (yyC <= '\u0baa')) ||
          (('\u0bae' <= yyC) && (yyC <= '\u0bb9')) ||
          (('\u0c05' <= yyC) && (yyC <= '\u0c0c')) ||
          (('\u0c0e' <= yyC) && (yyC <= '\u0c10')) ||
          (('\u0c12' <= yyC) && (yyC <= '\u0c28')) ||
          (('\u0c2a' <= yyC) && (yyC <= '\u0c33')) ||
          (('\u0c35' <= yyC) && (yyC <= '\u0c39')) ||
          (('\u0c60' <= yyC) && (yyC <= '\u0c61')) ||
          (('\u0c85' <= yyC) && (yyC <= '\u0c8c')) ||
          (('\u0c8e' <= yyC) && (yyC <= '\u0c90')) ||
          (('\u0c92' <= yyC) && (yyC <= '\u0ca8')) ||
          (('\u0caa' <= yyC) && (yyC <= '\u0cb3')) ||
          (('\u0cb5' <= yyC) && (yyC <= '\u0cb9')) ||
          ('\u0cbd' == yyC) ||
          ('\u0cde' == yyC) ||
          (('\u0ce0' <= yyC) && (yyC <= '\u0ce1')) ||
          (('\u0d05' <= yyC) && (yyC <= '\u0d0c')) ||
          (('\u0d0e' <= yyC) && (yyC <= '\u0d10')) ||
          (('\u0d12' <= yyC) && (yyC <= '\u0d28')) ||
          (('\u0d2a' <= yyC) && (yyC <= '\u0d39')) ||
          (('\u0d60' <= yyC) && (yyC <= '\u0d61')) ||
          (('\u0d85' <= yyC) && (yyC <= '\u0d96')) ||
          (('\u0d9a' <= yyC) && (yyC <= '\u0db1')) ||
          (('\u0db3' <= yyC) && (yyC <= '\u0dbb')) ||
          ('\u0dbd' == yyC) ||
          (('\u0dc0' <= yyC) && (yyC <= '\u0dc6')) ||
          (('\u0e01' <= yyC) && (yyC <= '\u0e30')) ||
          (('\u0e32' <= yyC) && (yyC <= '\u0e33')) ||
          (('\u0e40' <= yyC) && (yyC <= '\u0e46')) ||
          (('\u0e81' <= yyC) && (yyC <= '\u0e82')) ||
          ('\u0e84' == yyC) ||
          (('\u0e87' <= yyC) && (yyC <= '\u0e88')) ||
          ('\u0e8a' == yyC) ||
          ('\u0e8d' == yyC) ||
          (('\u0e94' <= yyC) && (yyC <= '\u0e97')) ||
          (('\u0e99' <= yyC) && (yyC <= '\u0e9f')) ||
          (('\u0ea1' <= yyC) && (yyC <= '\u0ea3')) ||
          ('\u0ea5' == yyC) ||
          ('\u0ea7' == yyC) ||
          (('\u0eaa' <= yyC) && (yyC <= '\u0eab')) ||
          (('\u0ead' <= yyC) && (yyC <= '\u0eb0')) ||
          (('\u0eb2' <= yyC) && (yyC <= '\u0eb3')) ||
          ('\u0ebd' == yyC) ||
          (('\u0ec0' <= yyC) && (yyC <= '\u0ec4')) ||
          ('\u0ec6' == yyC) ||
          (('\u0edc' <= yyC) && (yyC <= '\u0edd')) ||
          ('\u0f00' == yyC) ||
          (('\u0f40' <= yyC) && (yyC <= '\u0f47')) ||
          (('\u0f49' <= yyC) && (yyC <= '\u0f6a')) ||
          (('\u0f88' <= yyC) && (yyC <= '\u0f8b')) ||
          (('\u1000' <= yyC) && (yyC <= '\u1021')) ||
          (('\u1023' <= yyC) && (yyC <= '\u1027')) ||
          (('\u1029' <= yyC) && (yyC <= '\u102a')) ||
          (('\u1050' <= yyC) && (yyC <= '\u1055')) ||
          (('\u10a0' <= yyC) && (yyC <= '\u10c5')) ||
          (('\u10d0' <= yyC) && (yyC <= '\u10fa')) ||
          ('\u10fc' == yyC) ||
          (('\u1100' <= yyC) && (yyC <= '\u1159')) ||
          (('\u115f' <= yyC) && (yyC <= '\u11a2')) ||
          (('\u11a8' <= yyC) && (yyC <= '\u11f9')) ||
          (('\u1200' <= yyC) && (yyC <= '\u1248')) ||
          (('\u124a' <= yyC) && (yyC <= '\u124d')) ||
          (('\u1250' <= yyC) && (yyC <= '\u1256')) ||
          ('\u1258' == yyC) ||
          (('\u125a' <= yyC) && (yyC <= '\u125d')) ||
          (('\u1260' <= yyC) && (yyC <= '\u1288')) ||
          (('\u128a' <= yyC) && (yyC <= '\u128d')) ||
          (('\u1290' <= yyC) && (yyC <= '\u12b0')) ||
          (('\u12b2' <= yyC) && (yyC <= '\u12b5')) ||
          (('\u12b8' <= yyC) && (yyC <= '\u12be')) ||
          ('\u12c0' == yyC) ||
          (('\u12c2' <= yyC) && (yyC <= '\u12c5')) ||
          (('\u12c8' <= yyC) && (yyC <= '\u12d6')) ||
          (('\u12d8' <= yyC) && (yyC <= '\u1310')) ||
          (('\u1312' <= yyC) && (yyC <= '\u1315')) ||
          (('\u1318' <= yyC) && (yyC <= '\u135a')) ||
          (('\u1380' <= yyC) && (yyC <= '\u138f')) ||
          (('\u13a0' <= yyC) && (yyC <= '\u13f4')) ||
          (('\u1401' <= yyC) && (yyC <= '\u166c')) ||
          (('\u166f' <= yyC) && (yyC <= '\u1676')) ||
          (('\u1681' <= yyC) && (yyC <= '\u169a')) ||
          (('\u16a0' <= yyC) && (yyC <= '\u16ea')) ||
          (('\u16ee' <= yyC) && (yyC <= '\u16f0')) ||
          (('\u1700' <= yyC) && (yyC <= '\u170c')) ||
          (('\u170e' <= yyC) && (yyC <= '\u1711')) ||
          (('\u1720' <= yyC) && (yyC <= '\u1731')) ||
          (('\u1740' <= yyC) && (yyC <= '\u1751')) ||
          (('\u1760' <= yyC) && (yyC <= '\u176c')) ||
          (('\u176e' <= yyC) && (yyC <= '\u1770')) ||
          (('\u1780' <= yyC) && (yyC <= '\u17b3')) ||
          ('\u17d7' == yyC) ||
          ('\u17dc' == yyC) ||
          (('\u1820' <= yyC) && (yyC <= '\u1877')) ||
          (('\u1880' <= yyC) && (yyC <= '\u18a8')) ||
          (('\u1900' <= yyC) && (yyC <= '\u191c')) ||
          (('\u1950' <= yyC) && (yyC <= '\u196d')) ||
          (('\u1970' <= yyC) && (yyC <= '\u1974')) ||
          (('\u1980' <= yyC) && (yyC <= '\u19a9')) ||
          (('\u19c1' <= yyC) && (yyC <= '\u19c7')) ||
          (('\u1a00' <= yyC) && (yyC <= '\u1a16')) ||
          (('\u1b05' <= yyC) && (yyC <= '\u1b33')) ||
          (('\u1b45' <= yyC) && (yyC <= '\u1b4b')) ||
          (('\u1d00' <= yyC) && (yyC <= '\u1dbf')) ||
          (('\u1e00' <= yyC) && (yyC <= '\u1e9b')) ||
          (('\u1ea0' <= yyC) && (yyC <= '\u1ef9')) ||
          (('\u1f00' <= yyC) && (yyC <= '\u1f15')) ||
          (('\u1f18' <= yyC) && (yyC <= '\u1f1d')) ||
          (('\u1f20' <= yyC) && (yyC <= '\u1f45')) ||
          (('\u1f48' <= yyC) && (yyC <= '\u1f4d')) ||
          (('\u1f50' <= yyC) && (yyC <= '\u1f57')) ||
          ('\u1f59' == yyC) ||
          ('\u1f5b' == yyC) ||
          ('\u1f5d' == yyC) ||
          (('\u1f5f' <= yyC) && (yyC <= '\u1f7d')) ||
          (('\u1f80' <= yyC) && (yyC <= '\u1fb4')) ||
          (('\u1fb6' <= yyC) && (yyC <= '\u1fbc')) ||
          ('\u1fbe' == yyC) ||
          (('\u1fc2' <= yyC) && (yyC <= '\u1fc4')) ||
          (('\u1fc6' <= yyC) && (yyC <= '\u1fcc')) ||
          (('\u1fd0' <= yyC) && (yyC <= '\u1fd3')) ||
          (('\u1fd6' <= yyC) && (yyC <= '\u1fdb')) ||
          (('\u1fe0' <= yyC) && (yyC <= '\u1fec')) ||
          (('\u1ff2' <= yyC) && (yyC <= '\u1ff4')) ||
          (('\u1ff6' <= yyC) && (yyC <= '\u1ffc')) ||
          ('\u2071' == yyC) ||
          ('\u207f' == yyC) ||
          (('\u2090' <= yyC) && (yyC <= '\u2094')) ||
          ('\u2102' == yyC) ||
          ('\u2107' == yyC) ||
          (('\u210a' <= yyC) && (yyC <= '\u2113')) ||
          ('\u2115' == yyC) ||
          (('\u2119' <= yyC) && (yyC <= '\u211d')) ||
          ('\u2124' == yyC) ||
          ('\u2126' == yyC) ||
          ('\u2128' == yyC) ||
          (('\u212a' <= yyC) && (yyC <= '\u212d')) ||
          (('\u212f' <= yyC) && (yyC <= '\u2139')) ||
          (('\u213c' <= yyC) && (yyC <= '\u213f')) ||
          (('\u2145' <= yyC) && (yyC <= '\u2149')) ||
          ('\u214e' == yyC) ||
          (('\u2160' <= yyC) && (yyC <= '\u2184')) ||
          (('\u2c00' <= yyC) && (yyC <= '\u2c2e')) ||
          (('\u2c30' <= yyC) && (yyC <= '\u2c5e')) ||
          (('\u2c60' <= yyC) && (yyC <= '\u2c6c')) ||
          (('\u2c74' <= yyC) && (yyC <= '\u2c77')) ||
          (('\u2c80' <= yyC) && (yyC <= '\u2ce4')) ||
          (('\u2d00' <= yyC) && (yyC <= '\u2d25')) ||
          (('\u2d30' <= yyC) && (yyC <= '\u2d65')) ||
          ('\u2d6f' == yyC) ||
          (('\u2d80' <= yyC) && (yyC <= '\u2d96')) ||
          (('\u2da0' <= yyC) && (yyC <= '\u2da6')) ||
          (('\u2da8' <= yyC) && (yyC <= '\u2dae')) ||
          (('\u2db0' <= yyC) && (yyC <= '\u2db6')) ||
          (('\u2db8' <= yyC) && (yyC <= '\u2dbe')) ||
          (('\u2dc0' <= yyC) && (yyC <= '\u2dc6')) ||
          (('\u2dc8' <= yyC) && (yyC <= '\u2dce')) ||
          (('\u2dd0' <= yyC) && (yyC <= '\u2dd6')) ||
          (('\u2dd8' <= yyC) && (yyC <= '\u2dde')) ||
          (('\u3005' <= yyC) && (yyC <= '\u3007')) ||
          (('\u3021' <= yyC) && (yyC <= '\u3029')) ||
          (('\u3031' <= yyC) && (yyC <= '\u3035')) ||
          (('\u3038' <= yyC) && (yyC <= '\u303c')) ||
          (('\u3041' <= yyC) && (yyC <= '\u3096')) ||
          (('\u309d' <= yyC) && (yyC <= '\u309f')) ||
          (('\u30a1' <= yyC) && (yyC <= '\u30fa')) ||
          (('\u30fc' <= yyC) && (yyC <= '\u30ff')) ||
          (('\u3105' <= yyC) && (yyC <= '\u312c')) ||
          (('\u3131' <= yyC) && (yyC <= '\u318e')) ||
          (('\u31a0' <= yyC) && (yyC <= '\u31b7')) ||
          (('\u31f0' <= yyC) && (yyC <= '\u31ff')) ||
          (('\u3400' <= yyC) && (yyC <= '\u4db5')) ||
          (('\u4e00' <= yyC) && (yyC <= '\u9fbb')) ||
          (('\ua000' <= yyC) && (yyC <= '\ua48c')) ||
          (('\ua717' <= yyC) && (yyC <= '\ua71a')) ||
          (('\ua800' <= yyC) && (yyC <= '\ua801')) ||
          (('\ua803' <= yyC) && (yyC <= '\ua805')) ||
          (('\ua807' <= yyC) && (yyC <= '\ua80a')) ||
          (('\ua80c' <= yyC) && (yyC <= '\ua822')) ||
          (('\ua840' <= yyC) && (yyC <= '\ua873')) ||
          (('\uac00' <= yyC) && (yyC <= '\ud7a3')) ||
          (('\uf900' <= yyC) && (yyC <= '\ufa2d')) ||
          (('\ufa30' <= yyC) && (yyC <= '\ufa6a')) ||
          (('\ufa70' <= yyC) && (yyC <= '\ufad9')) ||
          (('\ufb00' <= yyC) && (yyC <= '\ufb06')) ||
          (('\ufb13' <= yyC) && (yyC <= '\ufb17')) ||
          ('\ufb1d' == yyC) ||
          (('\ufb1f' <= yyC) && (yyC <= '\ufb28')) ||
          (('\ufb2a' <= yyC) && (yyC <= '\ufb36')) ||
          (('\ufb38' <= yyC) && (yyC <= '\ufb3c')) ||
          ('\ufb3e' == yyC) ||
          (('\ufb40' <= yyC) && (yyC <= '\ufb41')) ||
          (('\ufb43' <= yyC) && (yyC <= '\ufb44')) ||
          (('\ufb46' <= yyC) && (yyC <= '\ufbb1')) ||
          (('\ufbd3' <= yyC) && (yyC <= '\ufd3d')) ||
          (('\ufd50' <= yyC) && (yyC <= '\ufd8f')) ||
          (('\ufd92' <= yyC) && (yyC <= '\ufdc7')) ||
          (('\ufdf0' <= yyC) && (yyC <= '\ufdfb')) ||
          (('\ufe70' <= yyC) && (yyC <= '\ufe74')) ||
          (('\ufe76' <= yyC) && (yyC <= '\ufefc')) ||
          (('\uff21' <= yyC) && (yyC <= '\uff3a')) ||
          (('\uff41' <= yyC) && (yyC <= '\uff5a')) ||
          (('\uff66' <= yyC) && (yyC <= '\uffbe')) ||
          (('\uffc2' <= yyC) && (yyC <= '\uffc7')) ||
          (('\uffca' <= yyC) && (yyC <= '\uffcf')) ||
          (('\uffd2' <= yyC) && (yyC <= '\uffd7')) ||
          (('\uffda' <= yyC) && (yyC <= '\uffdc'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud800':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc0b')) ||
                (('\udc0d' <= yyC) && (yyC <= '\udc26')) ||
                (('\udc28' <= yyC) && (yyC <= '\udc3a')) ||
                (('\udc3c' <= yyC) && (yyC <= '\udc3d')) ||
                (('\udc3f' <= yyC) && (yyC <= '\udc4d')) ||
                (('\udc50' <= yyC) && (yyC <= '\udc5d')) ||
                (('\udc80' <= yyC) && (yyC <= '\udcfa')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd74')) ||
                (('\udf00' <= yyC) && (yyC <= '\udf1e')) ||
                (('\udf30' <= yyC) && (yyC <= '\udf4a')) ||
                (('\udf80' <= yyC) && (yyC <= '\udf9d')) ||
                (('\udfa0' <= yyC) && (yyC <= '\udfc3')) ||
                (('\udfc8' <= yyC) && (yyC <= '\udfcf')) ||
                (('\udfd1' <= yyC) && (yyC <= '\udfd5'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc9d')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc05')) ||
                ('\udc08' == yyC) ||
                (('\udc0a' <= yyC) && (yyC <= '\udc35')) ||
                (('\udc37' <= yyC) && (yyC <= '\udc38')) ||
                ('\udc3c' == yyC) ||
                ('\udc3f' == yyC) ||
                (('\udd00' <= yyC) && (yyC <= '\udd15')) ||
                ('\ude00' == yyC) ||
                (('\ude10' <= yyC) && (yyC <= '\ude13')) ||
                (('\ude15' <= yyC) && (yyC <= '\ude17')) ||
                (('\ude19' <= yyC) && (yyC <= '\ude33'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud808':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udf6e')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud809':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc62')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc54')) ||
                (('\udc56' <= yyC) && (yyC <= '\udc9c')) ||
                (('\udc9e' <= yyC) && (yyC <= '\udc9f')) ||
                ('\udca2' == yyC) ||
                (('\udca5' <= yyC) && (yyC <= '\udca6')) ||
                (('\udca9' <= yyC) && (yyC <= '\udcac')) ||
                (('\udcae' <= yyC) && (yyC <= '\udcb9')) ||
                ('\udcbb' == yyC) ||
                (('\udcbd' <= yyC) && (yyC <= '\udcc3')) ||
                (('\udcc5' <= yyC) && (yyC <= '\udd05')) ||
                (('\udd07' <= yyC) && (yyC <= '\udd0a')) ||
                (('\udd0d' <= yyC) && (yyC <= '\udd14')) ||
                (('\udd16' <= yyC) && (yyC <= '\udd1c')) ||
                (('\udd1e' <= yyC) && (yyC <= '\udd39')) ||
                (('\udd3b' <= yyC) && (yyC <= '\udd3e')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd44')) ||
                ('\udd46' == yyC) ||
                (('\udd4a' <= yyC) && (yyC <= '\udd50')) ||
                (('\udd52' <= yyC) && (yyC <= '\udea5')) ||
                (('\udea8' <= yyC) && (yyC <= '\udec0')) ||
                (('\udec2' <= yyC) && (yyC <= '\udeda')) ||
                (('\udedc' <= yyC) && (yyC <= '\udefa')) ||
                (('\udefc' <= yyC) && (yyC <= '\udf14')) ||
                (('\udf16' <= yyC) && (yyC <= '\udf34')) ||
                (('\udf36' <= yyC) && (yyC <= '\udf4e')) ||
                (('\udf50' <= yyC) && (yyC <= '\udf6e')) ||
                (('\udf70' <= yyC) && (yyC <= '\udf88')) ||
                (('\udf8a' <= yyC) && (yyC <= '\udfa8')) ||
                (('\udfaa' <= yyC) && (yyC <= '\udfc2')) ||
                (('\udfc4' <= yyC) && (yyC <= '\udfcb'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud840':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\uded6')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud87e':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\ude1d')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '$':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '_':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\\':
        {
          yyResult = pUnicodeEscapeSequence(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Whitespace.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhitespace(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    Result       yyPredResult;
    boolean      yyPredMatched;
    int          yyBase;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    Void         yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\t' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\u000b':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\u3000':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\f' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (' ' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 5.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\u00a0':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\ufeff':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '-':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('-' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('>' == yyC) {

                  yyPredMatched = false;

                  yyPredResult = pSpace$$Choice1(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("whitespace expected", yyStart);
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 6.

    yyResult = pSingleLineComment$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pSingleLineCommentChar(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          String v$el$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<String>(v$el$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<String> a2s = yyRepValue1.reverse();

        StringBuilder buf = new StringBuilder();
        buf.append(a1);
        for (String s : a2s.list()) buf.append(s);
        handleComment(createSpan(yyStart,yyCount+1), buf.toString());

        yyValue = null;

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Alternative 7.

    yyResult = pMultiLineCommentNoLB(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pLineTerminatorSequence(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pMultiLineCommentChar(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            String v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for a1s.
          Pair<String> a1s = yyRepValue1.reverse();

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if ('*' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyC = character(yyIndex);
            if ('/' == yyC) {
              yyIndex = yyIndex + 1;

              StringBuilder buf = new StringBuilder();
              buf.append("/*");
              for (String s : a1s.list()) buf.append(s);
              buf.append("*/");
              handleComment(createSpan(yyStart,yyCount+1), buf.toString());

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("'*/' expected", yyBase);
            }
          } else {
            yyError = yyError.select("'*/' expected", yyBase);
          }
        } // End scope for a1s.
      }
    }

    // Done.
    yyError = yyError.select("whitespace expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.w.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pw(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pWhitespace(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.s.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ps(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pSpace(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.delete.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdelete(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = new Op(NodeUtil.makeASTNodeInfo(createSpan(yyStart, yyCount)), "delete");

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("delete expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("delete expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.anonymous.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result panonymous(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('n' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('y' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('m' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('o' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('u' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('s' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("anonymous expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("anonymous expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.assembly.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result passembly(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('s' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('m' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('b' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('l' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('y' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("assembly expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("assembly expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.as.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pas(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('s' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("as expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("as expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.break.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbreak(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('b' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('k' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("break expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("break expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.calldata.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcalldata(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('d' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('t' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('a' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("calldata expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("calldata expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.case.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcase(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("case expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("case expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.constant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pconstant(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('n' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('t' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("constant expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.constructor.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pconstructor(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('u' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('c' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('t' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('o' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('r' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyPredMatched = false;

                          yyPredResult = pidrest(yyIndex);
                          if (yyPredResult.hasValue()) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyValue = null;

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          } else {
                            yyError = yyError.select("constructor expected", yyStart);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("constructor expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.contract.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcontract(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('c' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('t' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("contract expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("contract expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.continue.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcontinue(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('u' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("continue expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("continue expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.default.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdefault(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('f' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('u' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('l' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('t' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("default expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("default expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.do.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdo(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("do expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("do expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.else.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pelse(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('l' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("else expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("else expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.enum.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result penum(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("enum expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("enum expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.event.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pevent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('v' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('n' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("event expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("event expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.external.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexternal(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('a' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('l' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("external expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("external expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.for.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfor(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("for expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("for expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.function.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfunction(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('u' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('c' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('o' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("function expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("function expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.if.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pif(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('f' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("if expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("if expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.import.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pimport(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('m' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("import expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("import expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.indexed.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pindexed(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('d' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('x' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('d' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("indexed expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("indexed expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.interface.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pinterface(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('f' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('a' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('c' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('e' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("interface expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("interface expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.internal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pinternal(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('a' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('l' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("internal expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("internal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.is.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pis(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('s' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("is expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("is expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.let.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plet(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('l' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("let expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("let expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.library.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plibrary(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('l' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('b' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('a' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('y' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("library expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("library expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.mapping.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmapping(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('m' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('p' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('g' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("mapping expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("mapping expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.modifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmodifier(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('m' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('d' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('i' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('f' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('r' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("modifier expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("modifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.new.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pnew(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('n' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('w' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("new expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("new expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.pragma.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ppragma(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('g' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('m' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("pragma expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("pragma expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.private.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pprivate(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('v' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('a' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("private expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("private expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.public.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ppublic(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('u' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('b' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('c' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("public expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("public expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.returns.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result preturns(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("returns expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("returns expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.struct.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pstruct(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('t' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("struct expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("struct expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.switch.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pswitch(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('w' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('h' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("switch expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("switch expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.throw.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pthrow(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('w' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("throw expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("throw expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.using.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pusing(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('u' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('s' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('n' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('g' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("using expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("using expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.var.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pvar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("var expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("var expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.while.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwhile(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("while expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("while expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.emit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pemit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('m' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("emit expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("emit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.false.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfalse(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("false expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("false expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.fixed.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfixed(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('x' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('d' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = "fixed";

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("fixed expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("fixed expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.from.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfrom(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("from expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("from expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.memory.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmemory(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('m' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('y' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("memory expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("memory expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.payable.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ppayable(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('y' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('b' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('l' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("payable expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("payable expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.pure.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ppure(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('u' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("pure expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("pure expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.return.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result preturn(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("return expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("return expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.storage.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pstorage(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('t' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('a' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('g' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("storage expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("storage expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.true.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptrue(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("true expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("true expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.ufixed.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pufixed(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('u' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('f' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('x' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "ufixed";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("ufixed expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("ufixed expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.view.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pview(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('w' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("view expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("view expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.StateMutability.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStateMutability(final int yyStart) throws IOException {
    Result     yyResult;
    FtnMod     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pconstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Constant(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ppayable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Payable(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = ppure(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Pure(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pview(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new View(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.StorageLocation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStorageLocation(final int yyStart) throws IOException {
    Result          yyResult;
    StorageLocation yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcalldata(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Calldata();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pmemory(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Memory();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pstorage(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Storage();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = ppayable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Payable(NodeUtil.makeASTNodeInfo(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  static List<SourceElement> nilJSes = Collections.<SourceElement>emptyList();
  static scala.collection.immutable.List<SourceElement> nilSes = toList(nilJSes);
  static scala.collection.immutable.List<TypeName> nilTys = toList(Collections.<TypeName>emptyList());
  static scala.collection.immutable.List<InheritanceSpecifier> nilSupers = toList(Collections.<InheritanceSpecifier>emptyList());
  static scala.collection.immutable.List<Parameter> nilParams = toList(Collections.<Parameter>emptyList());
  static scala.collection.immutable.List<EventParameter> nilEventParams = toList(Collections.<EventParameter>emptyList());
  static scala.collection.immutable.List<Statement> nilStmts = toList(Collections.<Statement>emptyList());
  static scala.collection.immutable.List<Expression> nilExprs = toList(Collections.<Expression>emptyList());
  static scala.collection.immutable.List<VariableDeclaration> nilVDs = toList(Collections.<VariableDeclaration>emptyList());
  static scala.collection.immutable.List<AssemblyItem> nilAIs = toList(Collections.<AssemblyItem>emptyList());
  static scala.collection.immutable.List<Id> nilIds = toList(Collections.<Id>emptyList());
  static scala.collection.immutable.List<FtnMod> nilFtnMods = toList(Collections.<FtnMod>emptyList());
  static scala.collection.immutable.List<Mod> nilMods = toList(Collections.<Mod>emptyList());
  static scala.collection.immutable.List<ContractPart> nilCPs = toList(Collections.<ContractPart>emptyList());
  static scala.collection.immutable.List<AssemblyCase> nilACs = toList(Collections.<AssemblyCase>emptyList());
  static scala.collection.immutable.List<AssemblyExpression> nilAEs = toList(Collections.<AssemblyExpression>emptyList());
  
  static <T> scala.collection.immutable.List<T> toList(List<T> jList) {
    return JavaConversions.asScalaBuffer(jList).toList();
  }
  
  Span createSpan(int start, int end) {
    int i = end;
    while ( i >= 0 && yyData.length > i && yyData[i] == ' ' ) { i--; }
    if ( i-1 >= start )
    end = i-1;
    else
    end = start;
    Column s = column(start);
    Column e = column(end);
    SourceLoc slStart = new SourceLoc(s.line, s.column, start);
    SourceLoc slEnd   = new SourceLoc(e.line, e.column, end);
    return new Span(s.file, slStart, slEnd);
  }
  
  private FileWriter fw;
  private BufferedWriter writer;
  private BufferedReader reader;
  private String logFile = column(0).file + ".log";
  private String comment = "";
  
  void handleComment(Span span, String message) {
    if (message.toLowerCase().indexOf("constructor") != -1)
    comment = message;
  }
  
  private ExcLog excLog = new ExcLog(toList(Collections.<SafError>emptyList()));
  public ExcLog excLog() {
    return excLog;
  }
  
  public Result SOLmain(final int yyStart) throws IOException {
    try {
      Result result = null;
      result = this.pSOL$File(yyStart);
      if (writer != null) writer.close();
      if (fw != null) fw.close();
      Files.deleteIfExists((new File(logFile)).toPath());
      return result;
    } finally {
      if (writer != null) writer.close();
      if (fw != null) fw.close();
    }
  }
  
  void initParser() {
    fw = Useful.fileNameToFileWriter(logFile);
    writer = new BufferedWriter(fw);
  }
  
  private void log(BufferedWriter writer, String msg) throws IOException {
    writer.write(msg + System.getProperty("line.separator"));
  }
  
  private static <T> List<T> list() {
    return Collections.emptyList();
  }
  
  public static <T> List<T> list(T x1) {
    ArrayList<T> result = new ArrayList<T>(1);
    result.add(x1);
    return result;
  }
  
  public static <U, T extends U> List<U> list(List<T> rest, U last) {
    List<U> l = new ArrayList<U>();
    l.addAll(rest);
    l.add(last);
    return l;
  }
  
  private static <T> List<T> cons(T x, List<T> y) {
    ArrayList<T> result = new ArrayList<T>(1 + y.size());
    result.add(x);
    result.addAll(y);
    return result;
  }
  
  /*
  * DecimalLiteral ::=
  *   DecimalIntegerLiteral . DecimalDigits? ExponentPart?
  * | DecimalIntegerLiteral ExponentPart?
  * | . DecimalDigits ExponentPart?
  *
  * DecimalIntegerLiteral ::=
  *   0
  * | NonZeroDigit DecimalDigits?
  *
  * DecimalDigit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
  *
  * NonZeroDigit ::= 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
  *
  * ExponentPart ::= (e | E) (+ | -)? DecimalDigit+
  */
  NumberLiteral makeNumberLiteral(BufferedWriter writer, Span span,
  String beforeDot, String dot,
  String afterDot, String exponent) throws IOException {
    if ((beforeDot + dot).equals("") ||
    ((beforeDot + afterDot).equals("") && !dot.equals("")) ||
    (!beforeDot.equals("") && dot.equals("") && !afterDot.equals("")))
    excLog.signal(new NoNumeralError(beforeDot + dot + afterDot + exponent));
    if (dot.equals("")) {
      if (exponent.equals(""))
      return new IntLiteral(NodeUtil.makeASTNodeInfo(span), new BigInteger(beforeDot), 10);
      else {
        int exp = 0;
        char second = exponent.charAt(1);
        if (Character.isDigit(second))
        exp = Integer.parseInt(exponent.substring(1));
        else if (second == '-')
        exp = -1 * Integer.parseInt(exponent.substring(2));
        else exp = Integer.parseInt(exponent.substring(2));
        if (exp < 0) {
          String str = beforeDot + dot + afterDot + exponent;
          str = new BigDecimal(str).toString();
          return new DoubleLiteral(NodeUtil.makeASTNodeInfo(span), str, Double.valueOf(str));
        } else
        return new IntLiteral(NodeUtil.makeASTNodeInfo(span),
        new BigInteger(beforeDot).multiply(BigInteger.TEN.pow(exp)),
        10);
      }
    } else {
      String str = beforeDot + dot + afterDot + exponent;
      return new DoubleLiteral(NodeUtil.makeASTNodeInfo(span), str, Double.valueOf(str));
    }
  }
  static {
    add(SOLIDITY_RESERVED, new String[] {
      "anonymous",    "assembly",     "as",           "break",
      "case",         "constant",
      "contract",        "continue",     "default",      "delete",
      "do",           "else",         "enum",
      "event",        "external",     "for",
      "function",     "if",           "import",       "indexed",
      "interface",    "internal",     "is",
      "let",          "library",      "mapping",
      "modifier",     "new",          "pragma",
      "private",      "public",       "returns",
      "struct",       "switch",       "throw",        "using",
      "var",          "while"
    });
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
